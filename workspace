#!/bin/bash

#
# Essentials

SCRIPT_NAME=$(basename $0)


TEXT_STYLE_NORMAL='\e[0m'
TEXT_STYLE_PROJECT_HEADER='\e[1;4m'
TEXT_STYLE_PROJECT_NAME='\e[1m'
TEXT_STYLE_BRANCH_NAME='\e[32m'
TEXT_STYLE_INTERACTION='\e[1;34m'
TEXT_STYLE_WARNING='\e[1;35m'
TEXT_STYLE_ERROR='\e[0;31m'
TEXT_STYLE_GIT_COLORED='-c color.ui=always'
TEXT_STYLE_GIT_PLAIN='-c color.ui=false'

OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN=''
OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END=''
OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_BEGIN=''
OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_END=''
OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_BEGIN=''
OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_END=''
OPTIONAL_OUTPUT_GIT_STYLE="$TEXT_STYLE_GIT_PLAIN"

OPTIONAL_INTERACTION_STYLE_BEGIN=''
OPTIONAL_INTERACTION_STYLE_END=''

OPTIONAL_WARNING_STYLE_BEGIN=''
OPTIONAL_WARNING_STYLE_END=''

OPTIONAL_ERROR_STYLE_BEGIN=''
OPTIONAL_ERROR_STYLE_END=''

PROGRESS_FUNCTION=nothing


printf-message()
{
	${PRINT_MESSAGE_BACKEND[@]} "$@"
}


printf-interaction()
{
	${PRINT_INTERACTION_BACKEND[@]} "$@"
}


printf-warning()
{
	local message=$(printf "$OPTIONAL_WARNING_STYLE_BEGIN$SCRIPT_NAME warning:$OPTIONAL_WARNING_STYLE_END "; printf "$@")
	${PRINT_WARNING_BACKEND[@]} "$message"
}


printf-error()
{
	local message=$(printf "$OPTIONAL_ERROR_STYLE_BEGIN$SCRIPT_NAME error:$OPTIONAL_ERROR_STYLE_END "; printf "$@")
	"${PRINT_ERROR_BACKEND[@]}" "$message"
}


printf-message-default()
{
	local message=$(printf "$@")
	printf '%s\n' "$message"
}


printf-interaction-default()
{
	local message=$(printf "$OPTIONAL_INTERACTION_STYLE_BEGIN"; printf "$@"; printf "$OPTIONAL_INTERACTION_STYLE_END")
	printf '%s' "$message"
}


printf-warning-default()
{
	local message=$(printf "$@")
	printf '%s' "$message"
}


printf-error-default()
{
	local message=$1
	printf '%s\n\n' "$message" >&2
}


TERMINAL_APPLICATION_APPLE=1
TERMINAL_APPLICATION_ITERM=2
TERMINAL_APPLICATION_GNOME=3
TERMINAL_APPLICATION_TMUX=4
TERMINAL_APPLICATION_UNKNOWN=255

current-terminal-application()
{
	local pid=$$
	while :
	do
		local parent_pid=$(ps -p $pid -o ppid=)
		if [ $? != 0 ] || [ $parent_pid == 0 ]
		then
			return $TERMINAL_APPLICATION_UNKNOWN
		fi

		local parent_name=$(ps -p $parent_pid -o comm= )
		case "$parent_name" in
			*Terminal.app/Contents/MacOS/Terminal)
				return $TERMINAL_APPLICATION_APPLE
				;;

			*iTerm.app/Contents/MacOS/iTerm2)
				return $TERMINAL_APPLICATION_ITERM
				;;

			*gnome-terminal*)
				return $TERMINAL_APPLICATION_GNOME
				;;

			tmux|'tmux: server')
				return $TERMINAL_APPLICATION_TMUX
				;;
		esac

		pid=$parent_pid
	done
}


current-shell()
{
	local parent_shell=$(ps -p $PPID -o comm=)
	printf '%s\n' "${parent_shell#-}"
}


if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN="$TEXT_STYLE_PROJECT_HEADER"
	OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END="$TEXT_STYLE_NORMAL"
	OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_BEGIN="$TEXT_STYLE_PROJECT_NAME"
	OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_END="$TEXT_STYLE_NORMAL"
	OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_BEGIN="$TEXT_STYLE_BRANCH_NAME"
	OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_END="$TEXT_STYLE_NORMAL"
	OPTIONAL_OUTPUT_GIT_STYLE="$TEXT_STYLE_GIT_COLORED"

	OPTIONAL_INTERACTION_STYLE_BEGIN="$TEXT_STYLE_INTERACTION"
	OPTIONAL_INTERACTION_STYLE_END="$TEXT_STYLE_NORMAL"

	OPTIONAL_WARNING_STYLE_BEGIN="$TEXT_STYLE_WARNING"
	OPTIONAL_WARNING_STYLE_END="$TEXT_STYLE_NORMAL"

	OPTIONAL_ERROR_STYLE_BEGIN="$TEXT_STYLE_ERROR"
	OPTIONAL_ERROR_STYLE_END="$TEXT_STYLE_NORMAL"
fi

if [ -t 1 ]
then
	PROGRESS_FUNCTION=print-progress-string
fi


CURRENT_SHELL=$(current-shell)

WORKSPACE_PATH="$PWD"

WORKSPACE_RC_DIR_NAME="$SCRIPT_NAME-script"
LOCAL_WORKSPACE_RC_PATH="./.$WORKSPACE_RC_DIR_NAME"
CONFIG_DIR_PATHS=("$LOCAL_WORKSPACE_RC_PATH" "$HOME/.config/$WORKSPACE_RC_DIR_NAME" "/etc/$WORKSPACE_RC_DIR_NAME")

CUSTOM_ACTIONS_FILE_NAME='custom-actions'
IMPLICIT_ARGUMENTS_FILE_NAME='implicit-arguments'
IGNORE_FILE_NAME='ignore-paths'
COMPLETION_PATH_FILTERS_FILE_NAME='completion-paths'

CACHE_DIR_PATH="$LOCAL_WORKSPACE_RC_PATH/cache"
CACHE_PROJECT_PATHS_PATH="$CACHE_DIR_PATH/project-paths"
CACHE_COMPLETION_SOURCE_PATHS_PATH="$CACHE_DIR_PATH/completion-source-paths"
CACHE_COMPLETION_PROJECT_NAMES_PATH="$CACHE_DIR_PATH/completion-project-names"


STANDARD_ACTIONS=(status list git foreach open)
STANDARD_ACTIONS_DESCRIPTIONS=('show git status for projects' 'list projects' 'run git command for each project' 'run command for each project' 'open projects in shell (default), terminal tabs or tmux panels')
ADDITIONAL_ACTIONS=(cache-workspace-info install-completion-script)

ALL_ACTIONS=("${STANDARD_ACTIONS[@]}" "${ADDITIONAL_ACTIONS[@]}")

BASH_COMPLETION_SCRIPT=\
'#!/bin/bash

_'"$SCRIPT_NAME"'_CONFIG_DIR_PATHS=('"${CONFIG_DIR_PATHS[@]}"')
_'"$SCRIPT_NAME"'_CUSTOM_ACTIONS_FILE_NAME='"$CUSTOM_ACTIONS_FILE_NAME"'
_'"$SCRIPT_NAME"'_COMPLETION_PATH_FILTERS_FILE_NAME='"$COMPLETION_PATH_FILTERS_FILE_NAME"'
_'"$SCRIPT_NAME"'_CACHE_COMPLETION_SOURCE_PATHS_PATH='"$CACHE_COMPLETION_SOURCE_PATHS_PATH"'
_'"$SCRIPT_NAME"'_CACHE_COMPLETION_PROJECT_NAMES_PATH='"$CACHE_COMPLETION_PROJECT_NAMES_PATH"'


_'"$SCRIPT_NAME"'-config-path-for-file()
{
	local config_file=$1

	local path
	for path in "${_'"$SCRIPT_NAME"'_CONFIG_DIR_PATHS[@]}"
	do
		if [ -r "$path/$config_file" ]
		then
			printf "%s/%s\n" "$path" "$config_file"
			return
		fi
	done

	return 1
}


_'"$SCRIPT_NAME"'-is-short-option()
{
	local string=$1
	local option=$2

	[ "${string:0:1}" == "-" ] && [ "${string:1:1}" != "-" ] && [ "${string: -1}" == "$option" ]
}


_'"$SCRIPT_NAME"'-cache-completion-sources()
{
	local completion_source_patterns_path=$1
	local cache_path=$2

	if [ -r "$completion_source_patterns_path" ] && [ "$cache_path" -nt "$completion_source_patterns_path" ]
	then
		return
	fi

	if [ -r "$completion_source_patterns_path" ] && [ "$cache_path" -ot "$completion_source_patterns_path" ]
	then
		local path_pattern_options=()
		local pattern
		while read -r pattern
		do
			if [ ${#path_pattern_options[@]} == 0 ]
			then
				path_pattern_options+=("(")
			else
				path_pattern_options+=("-or")
			fi

			path_pattern_options+=("-path" "${pattern:1:${#pattern}-2}")
		done < <(grep --extended-regexp --invert-match --regexp "^#" --regexp "^[ \t]*$" "$completion_source_patterns_path" | sed --expression "s/^/\"/" --expression "s/$/\"/")

		if [ "${#path_pattern_options[@]}" \> 0 ]
		then
			path_pattern_options+=(")")
		fi
	fi

	local git_dirs=($(find . "${path_pattern_options[@]}" -type d -name ".git"))
	local project_paths=()
	local git_dir
	for git_dir in "${git_dirs[@]}"
	do
		project_paths+=("$(dirname "$git_dir")")
	done

	printf "%s\n" "${project_paths[@]}" > "$cache_path"
}


_'"$SCRIPT_NAME"'-branch-list()
{
	local git_branch_command=$1
	local completion_source_patterns_file_name=$2

	local completion_source_patterns_path
	completion_source_patterns_path=$(_'"$SCRIPT_NAME"'-config-path-for-file "$completion_source_patterns_file_name")

	_'"$SCRIPT_NAME"'-cache-completion-sources "$completion_source_patterns_path" "$_'"$SCRIPT_NAME"'_CACHE_COMPLETION_SOURCE_PATHS_PATH"

	local branches=()
	local path
	while read -r path
	do
		branches+=($(cd "$path"; $git_branch_command))
	done < <(cat "$_'"$SCRIPT_NAME"'_CACHE_COMPLETION_SOURCE_PATHS_PATH")

	local tokens=()
	local branch
	for branch in "${branches[@]}"
	do
		local components
		IFS="/" read -ra components <<< "$branch"

		tokens+=("${components[@]}")
	done
	branches+=("${tokens[@]}")

	printf "%s\n" "${branches[@]}" | sort | uniq
}


_'"$SCRIPT_NAME"'-completion()
{
	if [ $COMP_CWORD == 1 ]
	then
		local ACTIONS=('"${ALL_ACTIONS[@]}"')
		local custom_actions_path
		custom_actions_path=$(_'"$SCRIPT_NAME"'-config-path-for-file "$_'"$SCRIPT_NAME"'_CUSTOM_ACTIONS_FILE_NAME")
		if [ $? == 0 ]
		then
			local line
			while read -r line
			do
				local action="${line%% *}"
				ACTIONS+=("$action")
			done < <(grep --extended-regexp --invert-match --regexp "^#" --regexp "^[ \t]*$" "$custom_actions_path")
		fi

		COMPREPLY=($(compgen -W "${ACTIONS[*]}" -- "${COMP_WORDS[1]}"))
		return
	fi

	local argument="${COMP_WORDS[$COMP_CWORD-1]}"

	if [ "$argument" == "--project" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "p"
	then
		if [ ! -r "$_'"$SCRIPT_NAME"'_CACHE_COMPLETION_PROJECT_NAMES_PATH" ]
		then
			return
		fi

		local projects=$(cat "$_'"$SCRIPT_NAME"'_CACHE_COMPLETION_PROJECT_NAMES_PATH")
		COMPREPLY=($(compgen -W "$projects" -- "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if [ "$argument" == "--branch" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "B"
	then
		local branches
		branches=$(_'"$SCRIPT_NAME"'-branch-list "git rev-parse --abbrev-ref HEAD" "$_'"$SCRIPT_NAME"'_COMPLETION_PATH_FILTERS_FILE_NAME")
		if [ $? != 0 ]
		then
			return
		fi

		COMPREPLY=($(compgen -W "$branches" -- "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if [ "$argument" == "--branches" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "b"
	then
		local branches
		branches=$(_'"$SCRIPT_NAME"'-branch-list "git for-each-ref --format=%(refname:short) refs/heads/**" "$_'"$SCRIPT_NAME"'_COMPLETION_PATH_FILTERS_FILE_NAME")
		if [ $? != 0 ]
		then
			return
		fi

		COMPREPLY=($(compgen -W "$branches" -- "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if [ "$argument" == "--remote-branches" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "r"
	then
		local branches
		branches=$(_'"$SCRIPT_NAME"'-branch-list "git for-each-ref --format=%(refname:short) refs/remotes/**" "$_'"$SCRIPT_NAME"'_COMPLETION_PATH_FILTERS_FILE_NAME")
		if [ $? != 0 ]
		then
			return
		fi

		COMPREPLY=($(compgen -W "$branches" -- "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if [ "$argument" == "--all-branches" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "a"
	then
		local branches
		branches=$(_'"$SCRIPT_NAME"'-branch-list "git for-each-ref --format=%(refname:short)" "$_'"$SCRIPT_NAME"'_COMPLETION_PATH_FILTERS_FILE_NAME")
		if [ $? != 0 ]
		then
			return
		fi

		COMPREPLY=($(compgen -W "$branches" -- "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	local completion=""
	if [ -r "$_'"$SCRIPT_NAME"'_CACHE_COMPLETION_PROJECT_NAMES_PATH" ]
	then
		completion+=$(cat "$_'"$SCRIPT_NAME"'_CACHE_COMPLETION_PROJECT_NAMES_PATH")
	fi

	completion+=$(_'"$SCRIPT_NAME"'-branch-list "git for-each-ref --format=%(refname:short) refs/heads/**" "$_'"$SCRIPT_NAME"'_COMPLETION_PATH_FILTERS_FILE_NAME")

	COMPREPLY=($(compgen -W "$completion" -- "${COMP_WORDS[$COMP_CWORD]}"))
}


complete -F _'"$SCRIPT_NAME"'-completion '"$SCRIPT_NAME"


CUSTOM_ACTIONS=()
CUSTOM_ACTIONS_OPTIONS=()
CUSTOM_ACTIONS_COMMANDS=()
CUSTOM_ACTIONS_DESCRIPTIONS=()

PREDICATES=()

PROMPT_TO_USE_REPOSITORY_FUNCTION=nothing
DEAL_WITH_FAILED_COMMAND_FUNCTION=deal-with-failed-command-manually
OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-shell
FOREACH_ARGUMENTS=()
PRINT_MESSAGE_BACKEND=(printf-message-default)
PRINT_INTERACTION_BACKEND=(printf-interaction-default)
PRINT_WARNING_BACKEND=(printf-warning-default)
PRINT_ERROR_BACKEND=(printf-error-default)
DO_JOB_FUNCTION=pick-project-and-perform-action
PERFORM_ACTION_FUNCTION=''
ABORT_OPEN_ACTION_EXIT_STATUS=66


#
# Options

OPTION_NEGATE_NEXT_PREDICATE=''
OPTION_STRICT_NEXT_PATTERN=''
OPTION_NON_DETACHED_HEAD=true


#
# Option dependent functions

prompt-user-to-select-project()
{
	"$PROMPT_TO_USE_REPOSITORY_FUNCTION" "$@"
}


deal-with-failed-command()
{
	"$DEAL_WITH_FAILED_COMMAND_FUNCTION" "$@"
}


open-projects()
{
	"$OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION" "$@"
}


do-job()
{
	"$DO_JOB_FUNCTION" "$@"
}


perform-action()
{
	"$PERFORM_ACTION_FUNCTION" "$@"
}


#
# Predicate related

make-match-pattern()
{
	local string=$1
	local flag=$2

	if [ -n "$flag" ]
	then
		printf '%s\n' "$string"
	else
		printf '*%s*\n' "$string"
	fi
}


add-predicate()
{
	local predicate=$1

	PREDICATES+=("$predicate")
}


run-predicates()
{
	local PROJECT_PATH=$1

	local predicate
	for predicate in "${PREDICATES[@]}"
	do
		local WORKSPACE_PROJECT_NAME=$(basename "$PROJECT_PATH")
		(cd "$PROJECT_PATH"; eval "$predicate" > /dev/null 2>&1)
		if [ $? != 0 ]
		then
			return 1
		fi
	done
}


#
# Stuff

nothing()
{
	:
}


command-exists()
{
	local name=$1

	command -v "$name" > /dev/null 2>&1
}


command-runs-successfully()
{
	local cmd=$1

	bash -c "$cmd test" &> /dev/null
}


prompt-yes-no()
{
	local print_backend=$1

	"$print_backend" "${@:2}"
	while :
	do
		local action
		read action
		case $action in
			y)
				return 0
				;;

			n)
				return 1
				;;

			*)
				printf-interaction '\nType "y" or "n"\n'
			;;
		esac
	done
}


deal-with-failed-command-manually()
{
	local retval=$1
	local path=$2

	if [ $retval == 0 ]
	then
		return
	fi

	printf '\n'
	if prompt-yes-no printf-warning "command exited with non-zero code.\nDo you want to open this project in shell to deal with error and run your command manualy? (y/n) "
	then
		"$CURRENT_SHELL" -c "cd '$path'; $CURRENT_SHELL"
	fi
}


normalize-path()
{
	local path=$1
	$(cd "$path"; pwd)
}


string-trim-spaces()
{
    local string=$1

    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"
    printf '%s\n' "$string"
}


string-trim-quotes()
{
	local string=$1

	local first_char="${string:0:1}"
	if [ "$first_char" == "'" ] || [ "$first_char" == '"' ]
	then
		printf '%s\n' "${string:1:${#string}-2}"
	else
		printf '%s\n' "$string"
	fi
}


array-contains()
{
	local value=$1
	local array=("${@:2}")

	local item
	for item in "${array[@]}"
	do
		if [ "$item" == "$value" ]
		then
			return 0
		fi
	done

	return 1
}


array-fill()
{
	local size=$1
	local value=$2

	printf "$value"'%.0s\n' {1..$size}
}


array-index-of()
{
	local value=$1
	local array=("${@:2}")

	local index=( 0 )
	local item
	for item in "${array[@]}"
	do
		if [ "$item" == "$value" ]
		then
			printf '%s\n' $index
			return
		fi

		(( ++index ))
	done

	return 1
}


max-string-length()
{
	local strings=("$@")

	local string=$1
	local max_length=$(( ${#string} ))
	for string in "${strings[@]:1}"
	do
		if (( ${#string} > $max_length ))
		then
			max_length=$(( ${#string} ))
		fi
	done

	return $max_length
}


repository-status-pretty()
{
	local path=$1

	local project_name=$(basename "$path")
	printf "$OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN"'%s'"$OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END"'\n' "$project_name"
	(cd "$path"; git $OPTIONAL_OUTPUT_GIT_STYLE status "${FOREACH_ARGUMENTS[@]}")
}


#
# Configuration

config-path-for-file()
{
	local config_file=$1

	local path
	for path in "${CONFIG_DIR_PATHS[@]}"
	do
		if [ -r "$path/$config_file" ]
		then
			printf '%s/%s\n' "$path" "$config_file"
			return
		fi
	done

	return 1
}


config-first-path-to-store-file()
{
	local config_file=$1

	printf '%s/%s\n' "${CONFIG_DIR_PATHS[0]}" "$config_file"
}


custom-actions-config-get-action()
{
	local string=$1

	string-trim-spaces "${string%% *}"
}


custom-actions-config-get-options()
{
	local string=$1
	local action=$2

	string="${string#$action}"
	string-trim-spaces "${string%%--*}"
}


custom-actions-config-get-command()
{
	local string=$1

	string="${string#*-- }"
	string-trim-spaces "${string%#*}"
}


custom-actions-config-get-description()
{
	local string=$1

	[[ $string =~ ^.*#.*$ ]] && string-trim-spaces "${line#*#}"
}


#
# Actions

cache-project-paths()
{
	local cache_path=$1
	local workspace_path=$2

	# make '! -path <pattern>' options for 'find'
	local ignore_pattern_options=()
	local config_ignore_path
	config_ignore_path="$(config-path-for-file "$IGNORE_FILE_NAME")"
	if [ $? == 0 ]
	then
		local pattern
		while read -r pattern
		do
			if [ ${#ignore_pattern_options} \> 0 ]
			then
				ignore_pattern_options+=('-and')
			fi

			# removing quotes, so they are not part of the pattern
			ignore_pattern_options+=('!' '-path' "${pattern:1:${#pattern}-2}")
		done < <(grep --extended-regexp --invert-match --regexp '^#' --regexp '^\s[ \t]*$' "$config_ignore_path" | sed --expression 's/^/"/' --expression 's/$/"/') # quoting patterns to prevent asterisk expansion
	fi

	# collect paths
	local git_dirs=($(find "$workspace_path" "${ignore_pattern_options[@]}" -type d -name '.git' | sort))
	local project_paths=()
	local git_dir
	for git_dir in "${git_dirs[@]}"
	do
		project_paths+=("$(dirname "$git_dir")")
	done

	printf '%s\n' "${project_paths[@]}" > "$cache_path"
}


cache-project-names()
{
	local cache_path=$1
	local project_paths=("${@:2}")

	# collect project names
	local project_list=()
	local project_path
	for project_path in "${project_paths[@]}"
	do
		local project_name=$(basename "$project_path")
		project_list+=("$project_name")
	done

	# split project names into tokens and store them with project names
	local parts=()
	local project_name
	for project_name in "${project_list[@]}"
	do
		local tokens
		IFS='.-_ ' read -ra tokens <<< "$project_name"
		parts+=("${tokens[@]}")
	done
	project_list+=("${parts[@]}")

	printf '%s\n' "${project_list[@]}" | sort | uniq > "$cache_path"
}


prompt-user-to-select-project-implementation()
{
	local project_path=$1
	local prompt=$2

	repository-status-pretty "$project_path"
	printf '\n'
	prompt-yes-no printf-interaction "$prompt"
}


show-repositories-status()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		repository-status-pretty "$path"
		printf '\n'
	done
}


list-repositories()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		local project_name=$(basename "$path")
		local head=$(cd "$path"; git $OPTIONAL_OUTPUT_GIT_STYLE rev-parse --abbrev-ref HEAD)
		printf "$OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_BEGIN"'%s'"$OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_END"' ['"$OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_BEGIN"'%s'"$OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_END"'] %s\n' "$project_name" "$head" ".${path#$PWD}"
	done
	printf '\n'
}


start-shell()
{
	local project_paths=("$@")

	local path
	for path in "${project_paths[@]}"
	do
		if ! prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			continue
		fi

		local project_name=$(basename "$path")
		printf "$OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN"'%s'"$OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END"'\n' "$project_name"
		"$CURRENT_SHELL" -c "cd '$path'; $CURRENT_SHELL"
		if [ $? == $ABORT_OPEN_ACTION_EXIT_STATUS ]
		then
			if prompt-yes-no printf-warning 'shell exited with abort open action exit status (%s). Do you want to stop opening projects? (y/n) ' "$ABORT_OPEN_ACTION_EXIT_STATUS"
			then
				break
			fi
		fi

		printf '\n'
	done
}


start-gnome-terminal()
{
	if ! command-exists 'gnome-terminal'
	then
		printf-error 'gnome-terminal is not installed'
		return 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	local gnome_terminal_options=()
	for path in "${selected_paths[@]}"
	do
		gnome_terminal_options+=("--tab --working-directory ${path}")
	done

	gnome-terminal ${gnome_terminal_options[@]}
}


start-apple-terminal()
{
	local project_paths=("$@")

	local project
	for path in "${project_paths[@]}"
	do
		osascript \
			-e 'tell application "Terminal" to activate' \
			-e 'tell application "System Events" to tell process "Terminal" to keystroke "t" using command down' \
			-e 'tell application "Terminal" to do script "cd '"'$path'"'" in selected tab of the front window' > /dev/null
	done
}


start-iterm()
{
	local project_paths=("$@")

	local project
	for path in "${project_paths[@]}"
	do
		osascript \
			-e 'tell application "iTerm"
					tell current window
						create tab with default profile
					end tell
					tell current tab of current window
						set _new_session to last item of sessions
					end tell
					tell _new_session
						select
						write text "cd '"'$path'"'"
					end tell
				end tell' > /dev/null
	done
}


start-tmux()
{
	if ! command-exists 'tmux'
	then
		printf-error 'tmux is not installed'
		return 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	local session_name=$(basename "$WORKSPACE_PATH")
	tmux new-session -d -s "$session_name" -c "${selected_paths[0]}"

	for path in "${selected_paths[@]:1}"
	do
		tmux split-window -v -p 50 -c "${path}"
		tmux select-layout tiled
	done

	tmux -2 attach-session -t "$session_name"
}


continue-tmux()
{
	if ! command-exists 'tmux'
	then
		printf-error 'tmux is not installed'
		return 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	tmux new-window -c "${selected_paths[0]}"

	for path in "${selected_paths[@]:1}"
	do
		tmux split-window -v -p 50 -c "${path}"
		tmux select-layout tiled
	done
}


foreach-project()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		if [ "$PROMPT_TO_USE_REPOSITORY_FUNCTION" != 'nothing' ]
		then
			if ! prompt-user-to-select-project "$path" 'Run your command with this repository? (y/n) '
			then
				printf '\n'
				continue
			fi
		else
			local project_name=$(basename "$path")
			printf "$OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN"'%s'"$OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END"'\n' "$project_name"
		fi

		bash -c "cd '$path'; ${FOREACH_ARGUMENTS[*]}"
		deal-with-failed-command $? "$path"
		printf '\n'
	done
}


#
# Jobs

show-help()
{
	max-string-length "${STANDARD_ACTIONS[@]}" "${CUSTOM_ACTIONS[@]}"
	local action_field_length=$(( $? + 2 ))

	local custom_action_help=''
	local index
	for (( index = 0; index < ${#CUSTOM_ACTIONS[@]}; ++index ))
	do
		local action_field=$(printf '%*s' -$action_field_length "${CUSTOM_ACTIONS[$index]}")
		local description_field="${CUSTOM_ACTIONS_DESCRIPTIONS[$index]}"
		if [ -z "$description_field" ]
		then
			if [ -n "${CUSTOM_ACTIONS_OPTIONS[$index]}" ]
			then
				local options="${CUSTOM_ACTIONS_OPTIONS[$index]} "
			else
				local options=''
			fi

			description_field="\$ $SCRIPT_NAME $options[<...>] -- ${CUSTOM_ACTIONS_COMMANDS[$index]} [<...>]"
		fi

		custom_action_help+="  $action_field$description_field\n"
	done

	local standard_action_help=''
	for (( index = 0; index < ${#STANDARD_ACTIONS[@]}; ++index ))
	do
		local action="${STANDARD_ACTIONS[$index]}"
		if array-contains "$action" "${CUSTOM_ACTIONS[@]}"
		then
			continue
		fi

		action_field=$(printf '%*s' -$action_field_length "$action")
		description_field="${STANDARD_ACTIONS_DESCRIPTIONS[$index]}"
		standard_action_help+="  $action_field$description_field\n"
	done

	printf \
"\e[1mUSAGE\e[0m
  $SCRIPT_NAME <action> [<options>...]

\e[1mACTIONS\e[0m
$standard_action_help$custom_action_help
\e[1mOPTIONS\e[0m
  <pattern>                         Both project names and local branch names pattern.
  -p | --project <pattern>          Project name pattern.
  -B | --branch <pattern>           Current branch name pattern.
  -b | --branches <pattern>         Branch name pattern for local branches.
  -r | --remote-branches <pattern>  Branch name pattern for remote branches.
  -a | --all-branches <pattern>     Branch name pattern for all branches.
  -t | --tags <pattern>             Tag name pattern.
  -s | --strict                     Match next pattern strictly.
  -n | --negate                     Negate next pattern.
  -P | --predicate <command>        Use shell command as a predicate.
  -u | --uncommited                 Match projects with uncommited changes.
  -d | --detached                   Match projects with detached HEAD.
  -D | --detached-only              Match only projects with detached HEAD.
  -W | --workspace-path <path>      Search path [default: current directory].
  -T | --tabs                       Open projects in current terminal tabs/panels.
  -A | --apple-terminal             Open projects in Apple terminal tabs.
  -G | --gnome-terminal             Open projects in Gnome terminal tabs.
  -I | --iterm                      Open projects in iTerm tabs.
  -X | --tmux                       Open projects in tmux panels.
  -i | --interactive                Chose projects to do your stuff with.
  -g | --ignore-failed              Do not prompt to deal with error for failed commands in 'git' and 'foreach'.
  -h | --help                       Show this message.

\e[1mADDITIONAL OPTIONS\e[0m
  --abort-open-with <0..127>        Abort 'open' action with exit status [default: 66].
  --progress-bar                    Show progress bar.
  --no-progress-bar                 Do not show progress bar.
  --print-message <command>         Print message with command.
  --print-interaction <command>     Print interactions with command.
  --print-warrning <command>        Print warning with command.
  --print-error <command>           Print message with command.
  --colored-output                  Use colored output.
  --colored-interactions            Use colored output for interactions.
  --colored-warnings                Use colored output for warnings.
  --colored-errors                  Use colored output for errors.
  --colored-everything              Use colored output for everything.
  --no-colored-output               Do not use colored output.
  --no-colored-interactions         Do not use colored output for interactions.
  --no-colored-warnings             Do not use colored output for warnings.
  --no-colored-errors               Do not use colored output for errors.
  --no-colored-anything             Do not use colored output for anything.

\e[1mADDITIONAL ACTIONS\e[0m
  install-completion-script  Install bash completion script for project and branch names.
  cache-workspace-info       Update project paths cache.

\e[1mMore information at \e[mhttps://github.com/shrpnsld/workspace\e[0m

"
}


pick-project-and-perform-action()
{
	if [ ! -r "$CACHE_PROJECT_PATHS_PATH" ]
	then
		cache-workspace-info
		if [ $? != 0 ]
		then
			return 1
		fi
	fi

	project_paths=($(cat "$CACHE_PROJECT_PATHS_PATH"))
	project_count="${#project_paths[@]}"
	if [ $project_count == 0 ]
	then
		printf-error 'no projects found'
		return 1
	fi

	matched_projects=()
	for (( index = 0; ; ++index ))
	do
		show-progress 'Scanning projects' $index $project_count

		if [ $index == $project_count ]
		then
			break;
		fi

		project_path="${project_paths[$index]}"
		if [ ! -d "$project_path" ]
		then
			# TODO: mark cache as outdated
			continue
		fi

		run-predicates "$project_path"
		if [ $? != 0 ]
		then
			continue
		fi

		matched_projects+=("$project_path")
	done

	if [ "${#matched_projects[@]}" == 0 ]
	then
		printf-message 'no matching projects found'
		return
	fi

	perform-action "${matched_projects[@]}"
}


install-completion-script()
{
	local bash_completion_dir='/etc/bash_completion.d/'
	if ! [ -w "$bash_completion_dir" ]
	then
		printf-error 'permission denied'
		return 1
	fi

	printf '%s\n' "$BASH_COMPLETION_SCRIPT" > "$bash_completion_dir/$SCRIPT_NAME"
	printf-message 'please restart shell'
}


cache-workspace-info()
{
	mkdir -p "$CACHE_DIR_PATH"
	if [ $? != 0 ]
	then
		printf-error 'failed to create "%s" directory' "$CACHE_DIR_PATH"
		return 1
	fi

	mkdir -p "$CACHE_DIR_PATH"
	if [ $? != 0 ]
	then
		printf-error 'failed to create "%s" directory' "$CACHE_DIR_PATH"
		return 1
	fi

	cache-project-paths "$CACHE_PROJECT_PATHS_PATH" "$WORKSPACE_PATH"

	local project_paths=($(cat "$CACHE_PROJECT_PATHS_PATH"))
	cache-project-names "$CACHE_COMPLETION_PROJECT_NAMES_PATH" "${project_paths[@]}"
}


#
# Parameters and options parsing/validating

PARAM_TYPE_SHORT_OPTION_LIST=1
PARAM_TYPE_LONG_OPTION=2
PARAM_TYPE_DELIMITER=3
PARAM_TYPE_STRING=4
PARAM_TYPE_BAD_PARAMETER=255

check-parameter()
{
	local string=$1

	if [ -z "$string" ]
	then
		return $PARAM_TYPE_BAD_PARAMETER
	fi

	if [ "${string:0:3}" == '--' ] && [ "${#string}" == 2 ]
	then
		return $PARAM_TYPE_DELIMITER
	fi

	if [ "${string:0:2}" == '--' ]
	then
		printf '%s\n' "${string#--}"
		return $PARAM_TYPE_LONG_OPTION
	fi

	if [ "${string:0:1}" == '-' ]
	then
		printf '%s\n' "${string#-}"
		return $PARAM_TYPE_SHORT_OPTION_LIST
	fi

	printf "$string"
	return $PARAM_TYPE_STRING
}


PARSE_OPTION_UNKNOWN_OPTION=255

parse-option()
{
	local option=$1
	local value=$2

	case "$option" in
		W|workspace-path)
			WORKSPACE_PATH=$(normalize-path "$value")
			return 1
			;;

		p|project)
			local pattern=$(make-match-pattern "$value" "$OPTION_STRICT_NEXT_PATTERN")
			add-predicate "$OPTION_NEGATE_NEXT_PREDICATE"' [[ $WORKSPACE_PROJECT_NAME == '"$pattern"' ]]'

			OPTION_NEGATE_NEXT_PREDICATE=''
			OPTION_STRICT_NEXT_PATTERN=''
			return 1
			;;

		B|branch)
			local pattern=$(make-match-pattern "$value" "$OPTION_STRICT_NEXT_PATTERN")
			add-predicate "$OPTION_NEGATE_NEXT_PREDICATE"' [[ $(git rev-parse --abbrev-ref HEAD) == '"$pattern"' ]]'

			OPTION_NEGATE_NEXT_PREDICATE=''
			OPTION_STRICT_NEXT_PATTERN=''
			return 1
			;;

		b|branches)
			add-predicate "$OPTION_NEGATE_NEXT_PREDICATE"' (git for-each-ref --format="%(refname:short)" "refs/heads/**" | grep --fixed-strings '"$OPTION_STRICT_NEXT_PATTERN $value"')'

			OPTION_NEGATE_NEXT_PREDICATE=''
			OPTION_STRICT_NEXT_PATTERN=''
			return 1
			;;

		r|remote-branches)
			add-predicate "$OPTION_NEGATE_NEXT_PREDICATE"' (git for-each-ref --format="%(refname:short)" "refs/remotes/**" | grep --fixed-strings '"$OPTION_STRICT_NEXT_PATTERN $value"')'

			OPTION_NEGATE_NEXT_PREDICATE=''
			OPTION_STRICT_NEXT_PATTERN=''
			return 1
			;;

		a|all-branches)
			add-predicate "$OPTION_NEGATE_NEXT_PREDICATE"' (git for-each-ref --format="%(refname:short)" | grep --fixed-strings '"$OPTION_STRICT_NEXT_PATTERN $value"')'

			OPTION_NEGATE_NEXT_PREDICATE=''
			OPTION_STRICT_NEXT_PATTERN=''
			return 1
			;;

		t|tags)
			add-predicate "$OPTION_NEGATE_NEXT_PREDICATE"' (git for-each-ref --format="%(refname:short)" "refs/tags/**" | grep --fixed-strings '"$OPTION_STRICT_NEXT_PATTERN $value"')'

			OPTION_NEGATE_NEXT_PREDICATE=''
			OPTION_STRICT_NEXT_PATTERN=''
			return 1
			;;

		P|predicate)
			add-predicate "$OPTION_NEGATE_NEXT_PREDICATE $value"

			OPTION_NEGATE_NEXT_PREDICATE=''
			return 1
			;;

		s|strict)
			OPTION_STRICT_NEXT_PATTERN='--line-regexp'
			;;

		n|negate)
			OPTION_NEGATE_NEXT_PREDICATE='!'
			;;

		u|uncommited)
			add-predicate '! git diff-index --quiet HEAD --'
			;;

		d|detached)
			OPTION_NON_DETACHED_HEAD=false
			;;

		D|detached-only)
			OPTION_NON_DETACHED_HEAD=false
			add-predicate '! git symbolic-ref --quiet HEAD'
			;;

		T|tabs)
			current-terminal-application
			case $? in
				$TERMINAL_APPLICATION_APPLE)
					OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-apple-terminal
					;;

				$TERMINAL_APPLICATION_ITERM)
					OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-iterm
					;;

				$TERMINAL_APPLICATION_GNOME)
					OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-gnome-terminal
					;;

				$TERMINAL_APPLICATION_TMUX)
					OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=continue-tmux
					;;

				$TERMINAL_APPLICATION_UNKNOWN)
					OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=nothing
					;;
			esac
			;;

		A|apple-terminal)
			OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-apple-terminal
			;;

		G|gnome-terminal)
			OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-gnome-terminal
			;;

		I|iterm)
			OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-iterm
			;;

		X|tmux)
			OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-tmux
			;;

		i|interactive)
			PROMPT_TO_USE_REPOSITORY_FUNCTION=prompt-user-to-select-project-implementation
			;;

		g|ignore-failed)
			DEAL_WITH_FAILED_COMMAND_FUNCTION=nothing
			;;

		progress-bar)
			PROGRESS_FUNCTION=print-progress-string
			;;

		no-progress-bar)
			PROGRESS_FUNCTION=nothing
			;;

		colored-output)
			OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN="$TEXT_STYLE_PROJECT_HEADER"
			OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END="$TEXT_STYLE_NORMAL"
			OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_BEGIN="$TEXT_STYLE_PROJECT_NAME"
			OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_END="$TEXT_STYLE_NORMAL"
			OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_BEGIN="$TEXT_STYLE_BRANCH_NAME"
			OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_END="$TEXT_STYLE_NORMAL"
			OPTIONAL_OUTPUT_GIT_STYLE="$TEXT_STYLE_GIT_COLORED"
			;;

		colored-interactions)
			OPTIONAL_INTERACTION_STYLE_BEGIN="$TEXT_STYLE_INTERACTION"
			OPTIONAL_INTERACTION_STYLE_END="$TEXT_STYLE_NORMAL"
			;;

		colored-warnings)
			OPTIONAL_WARNING_STYLE_BEGIN="$TEXT_STYLE_WARNING"
			OPTIONAL_WARNING_STYLE_END="$TEXT_STYLE_NORMAL"
			;;

		colored-errors)
			OPTIONAL_ERROR_STYLE_BEGIN="$TEXT_STYLE_ERROR"
			OPTIONAL_ERROR_STYLE_END="$TEXT_STYLE_NORMAL"
			;;

		colored-everything)
			OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN="$TEXT_STYLE_PROJECT_HEADER"
			OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END="$TEXT_STYLE_NORMAL"
			OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_BEGIN="$TEXT_STYLE_PROJECT_NAME"
			OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_END="$TEXT_STYLE_NORMAL"
			OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_BEGIN="$TEXT_STYLE_BRANCH_NAME"
			OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_END="$TEXT_STYLE_NORMAL"
			OPTIONAL_OUTPUT_GIT_STYLE="$TEXT_STYLE_GIT_COLORED"

			OPTIONAL_INTERACTION_STYLE_BEGIN="$TEXT_STYLE_INTERACTION"
			OPTIONAL_INTERACTION_STYLE_END="$TEXT_STYLE_NORMAL"

			OPTIONAL_WARNING_STYLE_BEGIN="$TEXT_STYLE_WARNING"
			OPTIONAL_WARNING_STYLE_END="$TEXT_STYLE_NORMAL"

			OPTIONAL_ERROR_STYLE_BEGIN="$TEXT_STYLE_ERROR"
			OPTIONAL_ERROR_STYLE_END="$TEXT_STYLE_NORMAL"
			;;

		no-colored-output)
			OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN=''
			OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END=''
			OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_BEGIN=''
			OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_END=''
			OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_BEGIN=''
			OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_END=''
			OPTIONAL_OUTPUT_GIT_STYLE="$TEXT_STYLE_GIT_PLAIN"
			;;

		no-colored-interactions)
			OPTIONAL_INTERACTION_STYLE_BEGIN=''
			OPTIONAL_INTERACTION_STYLE_END=''
			;;

		no-colored-warnings)
			OPTIONAL_WARNING_STYLE_BEGIN=''
			OPTIONAL_WARNING_STYLE_END=''
			;;

		no-colored-errors)
			OPTIONAL_ERROR_STYLE_BEGIN=''
			OPTIONAL_ERROR_STYLE_END=''
			;;

		no-colored-anything)
			OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_BEGIN=''
			OPTIONAL_OUTPUT_PROJECT_HEADER_STYLE_END=''
			OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_BEGIN=''
			OPTIONAL_OUTPUT_PROJECT_NAME_STYLE_END=''
			OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_BEGIN=''
			OPTIONAL_OUTPUT_BRANCH_NAME_STYLE_END=''
			OPTIONAL_OUTPUT_GIT_STYLE="$TEXT_STYLE_GIT_PLAIN"

			OPTIONAL_INTERACTION_STYLE_BEGIN=''
			OPTIONAL_INTERACTION_STYLE_END=''

			OPTIONAL_WARNING_STYLE_BEGIN=''
			OPTIONAL_WARNING_STYLE_END=''

			OPTIONAL_ERROR_STYLE_BEGIN=''
			OPTIONAL_ERROR_STYLE_END=''
			;;

		print-message)
			local trimmed_value=$(string-trim-quotes "$value")
			local cmd=()
			eval 'local word; for word in '"$trimmed_value"'; do cmd+=("$word"); done'
			if command-runs-successfully "${cmd[@]}"
			then
				PRINT_MESSAGE_BACKEND=("${cmd[@]}")
			fi
			return 1
			;;

		print-interaction)
			local trimmed_value=$(string-trim-quotes "$value")
			local cmd=()
			eval 'local word; for word in '"$trimmed_value"'; do cmd+=("$word"); done'
			if command-runs-successfully "${cmd[@]}"
			then
				PRINT_INTERACTION_BACKEND=("${cmd[@]}")
			fi
			return 1
			;;

		print-warning)
			local trimmed_value=$(string-trim-quotes "$value")
			local cmd=()
			eval 'local word; for word in '"$trimmed_value"'; do cmd+=("$word"); done'
			if command-runs-successfully "${cmd[@]}"
			then
				PRINT_WARNING_BACKEND=("${cmd[@]}")
			fi
			return 1
			;;

		print-error)
			local trimmed_value=$(string-trim-quotes "$value")
			local cmd=()
			eval 'local word; for word in '"$trimmed_value"'; do cmd+=("$word"); done'
			if command-runs-successfully "${cmd[@]}"
			then
				PRINT_ERROR_BACKEND=("${cmd[@]}")
			fi
			return 1
			;;

		abort-open-with)
			ABORT_OPEN_ACTION_EXIT_STATUS=$value
			return 1
			;;

		*)
			return $PARSE_OPTION_UNKNOWN_OPTION
			;;
	esac
}


PARSE_ACTION_UNKNOWN_ACTION=255

parse-action()
{
	local action=$1

	if array-contains "$action" "${CUSTOM_ACTIONS[@]}"
	then
		PERFORM_ACTION_FUNCTION=foreach-project
		local index=$(array-index-of "$action" "${CUSTOM_ACTIONS[@]}")

		local commands=()
		eval 'for word in '"${CUSTOM_ACTIONS_COMMANDS[$index]}"'; do commands+=("$word"); done'
		FOREACH_ARGUMENTS=("${commands[@]}" "${FOREACH_ARGUMENTS[@]}")
		return $index
	fi

	case "$action" in
		''|-h|--help)
			DO_JOB_FUNCTION=show-help
			;;

		cache-workspace-info)
			DO_JOB_FUNCTION=cache-workspace-info
			;;

		install-completion-script)
			DO_JOB_FUNCTION=install-completion-script
			;;

		status)
			PERFORM_ACTION_FUNCTION=show-repositories-status
			;;

		list)
			PERFORM_ACTION_FUNCTION=list-repositories
			;;

		open)
			PERFORM_ACTION_FUNCTION=open-projects
			;;

		git)
			PERFORM_ACTION_FUNCTION=foreach-project
			FOREACH_ARGUMENTS=(git)
			;;

		foreach)
			PERFORM_ACTION_FUNCTION=foreach-project
			;;

		*)
			return $PARSE_ACTION_UNKNOWN_ACTION
			;;
	esac
}


parse-parameters()
{
	local parameters=("$@")

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter=$(check-parameter "${parameters[$parameter_index]}")
		local parameter_type=$?
		if [ $parameter_type == $PARAM_TYPE_STRING ]
		then
			local pattern=$(make-match-pattern "$parameter" "$OPTION_STRICT_NEXT_PATTERN")
			add-predicate "$OPTION_NEGATE_NEXT_PREDICATE"' ([[ $WORKSPACE_PROJECT_NAME == '"$pattern"' ]] || git for-each-ref --format="%(refname:short)" "refs/heads/**" | grep --fixed-strings '"$OPTION_STRICT_NEXT_PATTERN $parameter"')'

			OPTION_NEGATE_NEXT_PREDICATE=''
			OPTION_STRICT_NEXT_PATTERN=''
			continue
		fi

		case $parameter_type in
			$PARAM_TYPE_SHORT_OPTION_LIST)
				local value="${parameters[$parameter_index + 1]}"

				local index
				for (( index = 0; index < ${#parameter}; ++index ))
				do
					local option="${parameter:$index:1}"
					parse-option "$option" "$value"
					local retval=$?
					case $retval in
						$PARSE_OPTION_UNKNOWN_OPTION)
							printf-error 'unknown option "%s"' "$option"
							return 1
							;;

						*)
							(( parameter_index += retval ))
							;;
					esac
				done

				continue
				;;

			$PARAM_TYPE_LONG_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				parse-option "$parameter" "$value"
				local retval=$?
				case $retval in
					$PARSE_OPTION_UNKNOWN_OPTION)
						printf-error 'unknown long option "%s"' "$parameter"
						return 1
						;;

					*)
						(( parameter_index += retval ))
						;;
				esac
				continue
				;;

			$PARAM_TYPE_DELIMITER)
				(( ++parameter_index ))
				break
				;;
		esac
	done

	if [ $parameter_index == ${#parameters[@]} ]
	then
		return
	fi

	if [ $parameter_type == $PARAM_TYPE_DELIMITER ]
	then
		for (( ; parameter_index < ${#parameters[@]}; ++parameter_index ))
		do
			local parameter="${parameters[$parameter_index]}"
			FOREACH_ARGUMENTS+=("$parameter")
		done
	fi
}


validate-options()
{
	local action=$1

	case $action in
		status|list)
			if array-contains $OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION 'start-apple-terminal' 'start-gnome-terminal' 'start-iterm' 'start-tmux' 'continue-tmux'
			then
				printf-error '"-t", "--tabs", "--apple-terminal", "--gnome-terminal" or "--iterm" should be used with "open" action'
				return 1
			fi

			if [ "$PROMPT_TO_USE_REPOSITORY_FUNCTION" != 'nothing' ]
			then
				printf-error '"-i" ("--interactive") should be used with "open", "foreach" or "git" action'
				return 1
			fi

			if [ "$DEAL_WITH_FAILED_COMMAND_FUNCTION" == 'nothing' ]
			then
				printf-error '"-g" ("--ignore-failed") should be used with "foreach" or "git" action'
				return 1
			fi
			;;

		open)
			if [ "$DEAL_WITH_FAILED_COMMAND_FUNCTION" == 'nothing' ]
			then
				printf-error '"-g" ("--ignore-failed") should be used with "foreach" or "git" action'
				return 1
			fi
			;;

		git|foreach)
			if array-contains $OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION 'start-apple-terminal' 'start-gnome-terminal' 'start-iterm' 'start-tmux' 'continue-tmux'
			then
				printf-error '"-t", "--tabs", "--apple-terminal", "--gnome-terminal" or "--iterm" should be used with "open" action'
				return 1
			fi
			;;
	esac

	if [ -n "$WORKSPACE_PATH" ] && [ ! -d "$WORKSPACE_PATH" ]
	then
		printf-error "'"'%s'"'"' does not exist' "$WORKSPACE_PATH"
		return 1
	fi

	if [ "$OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION" == 'nothing' ]
	then
		printf-error 'failed to detect terminal application, or terminal is not supported. Try to specify terminal explicitly with -A, -G, -I, -X'
		return 1
	fi
}


#
# Progress

PROGRESS_BAR_CHARACTER='#'
PROGRESS_BAR_SIZE=20
PROGRESS_BAR_FILL=$(printf "$PROGRESS_BAR_CHARACTER"'%.0s' $(seq 1 $PROGRESS_BAR_SIZE))

make-progress-string()
{
	local description=$1
	local current=$2
	local total=$3

	local percentage=$(( current * 100 / total ))
	local current_length=$(( percentage * PROGRESS_BAR_SIZE / 100 ))
	local fill="${PROGRESS_BAR_FILL:$PROGRESS_BAR_SIZE-$current_length}"
	printf '%s %*s/%s  [%*s] % 3s%%' "$description" ${#total} $current $total -$PROGRESS_BAR_SIZE "$fill" "$percentage"
}


print-progress-string()
{
	local description=$1
	local current=$2
	local total=$3

	local progress_string=$(make-progress-string "$description" $current $total)
	printf '\r%s' "$progress_string"
	if [ $current == $total ]
	then
		printf '\n\n'
	fi
}


show-progress()
{
	"$PROGRESS_FUNCTION" "$@"
}


#
# Custom commands

custom_actions_path="$(config-path-for-file "$CUSTOM_ACTIONS_FILE_NAME")"
if [ $? == 0 ]
then
	while read -r line
	do
		action=$(custom-actions-config-get-action "$line")
		cmd=$(custom-actions-config-get-command "$line")
		options=$(custom-actions-config-get-options "$line" "$action")
		description=$(custom-actions-config-get-description "$line")

		CUSTOM_ACTIONS+=("$action")
		CUSTOM_ACTIONS_OPTIONS+=("$options")
		CUSTOM_ACTIONS_COMMANDS+=("$cmd")
		CUSTOM_ACTIONS_DESCRIPTIONS+=("$description")
	done < <(grep --extended-regexp --invert-match --regexp '^#' --regexp '^\s[ \t]*$' "$custom_actions_path")
fi


#
# Implicit arguments

implicit_arguments=()
implicit_arguments_path=$(config-path-for-file "$IMPLICIT_ARGUMENTS_FILE_NAME")
if [ $? == 0 ]
then
	while read -r line
	do
		option="${line%% *}"
		value="${line#* }"
		implicit_arguments+=("$option" "$value")
	done < <(grep --extended-regexp --invert-match --regexp '^#' --regexp '^\s[ \t]*$' "$implicit_arguments_path")
fi

parse-parameters "${implicit_arguments[@]}"


#
# Sanity checks

if ! command-exists 'git'
then
	printf-error 'git is not installed'
	exit 1
fi


#
# Parameters

action=$1

parse-action "$action"
retval=$?
if [ $retval == $PARSE_ACTION_UNKNOWN_ACTION ]
then
	printf-error 'unknown action "%s"' "$action"
	exit 1
fi

eval 'for option in '"${CUSTOM_ACTIONS_OPTIONS[$retval]}"'; do custom_action_options+=("$option"); done'
all_parameters=("${custom_action_options[@]}" "${@:2}")

parse-parameters "${all_parameters[@]}" && validate-options "$action"
if [ $? != 0 ]
then
	exit 1
fi

# TODO: find better place for this (should be in 'parse-parameters', but since 'parse-parameters' is called two times, this will always be set after the first call).
if $OPTION_NON_DETACHED_HEAD
then
	add-predicate 'git symbolic-ref --quiet HEAD'
fi


#
# Main

do-job

