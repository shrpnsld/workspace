#!/bin/bash

#
# Essentials

SCRIPT_NAME=$(basename $0)


TEXT_STYLE_NORMAL='\e[0m'
TEXT_STYLE_INTERACTION='\e[1;34m'
TEXT_STYLE_WARNING='\e[1;35m'
TEXT_STYLE_ERROR='\e[0;31m'


OPTIONAL_INTERACTION_STYLE_BEGIN=''
OPTIONAL_INTERACTION_STYLE_END=''
OPTIONAL_WARNING_STYLE_BEGIN=''
OPTIONAL_WARNING_STYLE_END=''
OPTIONAL_ERROR_STYLE_BEGIN=''
OPTIONAL_ERROR_STYLE_END=''


printf-message()
{
	$PRINT_MESSAGE_BACKEND "$@"
}


printf-interaction()
{
	$PRINT_INTERACTION_BACKEND "$@"
}


printf-warning()
{
	local message=$(printf "$OPTIONAL_WARNING_STYLE_BEGIN$SCRIPT_NAME warning:$OPTIONAL_WARNING_STYLE_END "; printf "$@")

	$PRINT_WARNING_BACKEND "$message"
}


printf-error()
{
	local message=$(printf "$OPTIONAL_ERROR_STYLE_BEGIN$SCRIPT_NAME error:$OPTIONAL_ERROR_STYLE_END "; printf "$@")

	$PRINT_ERROR_BACKEND "$message"
}


printf-message-default()
{
	local message=$(printf "$@")

	printf '%s\n' "$message"
}


printf-interaction-default()
{
	local message=$(printf "$OPTIONAL_INTERACTION_STYLE_BEGIN"; printf "$@"; printf "$OPTIONAL_INTERACTION_STYLE_END")

	printf '%s' "$message"
}


printf-warning-default()
{
	local message=$(printf "$@")

	printf '%s' "$message"
}


printf-error-default()
{
	local message=$1

	printf '%s\n\n' "$message" >&2
}


TERMINAL_APPLICATION_APPLE=1
TERMINAL_APPLICATION_ITERM=2
TERMINAL_APPLICATION_GNOME=3
TERMINAL_APPLICATION_TMUX=4
TERMINAL_APPLICATION_UNKNOWN=255

current-terminal-application()
{
	local pid=$$
	while :
	do
		local parent_pid=$(ps -p $pid -o ppid=)
		if [ $? != 0 ] || [ $parent_pid == 0 ]
		then
			return $TERMINAL_APPLICATION_UNKNOWN
		fi

		local parent_name=$(ps -p $parent_pid -o comm= )
		case "$parent_name" in
			*Terminal.app/Contents/MacOS/Terminal)
				return $TERMINAL_APPLICATION_APPLE
				;;

			*iTerm.app/Contents/MacOS/iTerm2)
				return $TERMINAL_APPLICATION_ITERM
				;;

			*gnome-terminal*) # TODO: need to check this
				return $TERMINAL_APPLICATION_GNOME
				;;

			tmux)
				return $TERMINAL_APPLICATION_TMUX
				;;
		esac

		pid=$parent_pid
	done
}


current-shell()
{
	local parent_shell=$(ps -p $PPID -o comm=)
	printf '%s\n' "${parent_shell#-}"
}


if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	OPTIONAL_INTERACTION_STYLE_BEGIN="$TEXT_STYLE_INTERACTION"
	OPTIONAL_INTERACTION_STYLE_END="$TEXT_STYLE_NORMAL"
	OPTIONAL_WARNING_STYLE_BEGIN="$TEXT_STYLE_WARNING"
	OPTIONAL_WARNING_STYLE_END="$TEXT_STYLE_NORMAL"
	OPTIONAL_ERROR_STYLE_BEGIN="$TEXT_STYLE_ERROR"
	OPTIONAL_ERROR_STYLE_END="$TEXT_STYLE_NORMAL"
fi


CURRENT_SHELL=$(current-shell)
CURRENT_TERMINAL_APPLICATION=$TERMINAL_APPLICATION_UNKNOWN

WORKSPACE_PATH="$PWD"

CUSTOM_ACTIONS=()
CUSTOM_ACTIONS_OPTIONS=()
CUSTOM_ACTIONS_COMMANDS=()
CUSTOM_ACTIONS_DESCRIPTIONS=()

WORKSPACE_RC_DIR_NAME="$SCRIPT_NAME-script"

CUSTOM_ACTIONS_FILE_NAME='custom-actions'
IMPLICIT_ARGUMENTS_FILE_NAME='implicit-arguments'
IGNORE_FILE_NAME='ignore-paths'
COMPLETION_SOURCES_PATTERNS_FILE_NAME='completion-sources'

LOCAL_WORKSPACE_RC_PATH="./.$WORKSPACE_RC_DIR_NAME"

CONFIG_DIR_PATHS=("$LOCAL_WORKSPACE_RC_PATH" "$HOME/.config/$WORKSPACE_RC_DIR_NAME" "/etc/$WORKSPACE_RC_DIR_NAME")

CACHE_DIR_PATH="$LOCAL_WORKSPACE_RC_PATH/cache"
CACHE_PROJECT_PATHS_PATH="$CACHE_DIR_PATH/project-paths"

COMPLETION_DIR_PATH="$LOCAL_WORKSPACE_RC_PATH/completion"
COMPLETION_SOURCE_PROJECTS_PATH="$COMPLETION_DIR_PATH/source-projects"
COMPLETION_PROJECT_LIST_PATH="$COMPLETION_DIR_PATH/project-list"

SCRIPT_ACTIONS=('status' 'list' 'git' 'foreach' 'open' 'cache-workspace-info' 'install-completion-script')

BASH_COMPLETION_SCRIPT=\
'#!/bin/bash

_'"$SCRIPT_NAME"'_CONFIG_DIR_PATHS=('"${CONFIG_DIR_PATHS[@]}"')
_'"$SCRIPT_NAME"'_CUSTOM_ACTIONS_FILE_NAME='"$CUSTOM_ACTIONS_FILE_NAME"'
_'"$SCRIPT_NAME"'_COMPLETION_SOURCE_PATTERNS_FILE_NAME='"$COMPLETION_SOURCES_PATTERNS_FILE_NAME"'
_'"$SCRIPT_NAME"'_COMPLETION_SOURCE_PROJECT_PATHS='"$COMPLETION_SOURCE_PROJECTS_PATH"'
_'"$SCRIPT_NAME"'_COMPLETION_PROJECT_LIST_PATH='"$COMPLETION_PROJECT_LIST_PATH"'


_'"$SCRIPT_NAME"'-config-path-for-file()
{
	local config_file=$1

	local path
	for path in "${_'"$SCRIPT_NAME"'_CONFIG_DIR_PATHS[@]}"
	do
		if [ -r "$path/$config_file" ]
		then
			printf "%s/%s\n" "$path" "$config_file"
			return
		fi
	done

	return 1
}


_'"$SCRIPT_NAME"'-is-short-option()
{
	local string=$1
	local option=$2

	[ "${string:0:1}" == "-" ] && [ "${string:1:1}" != "-" ] && [ "${string: -1}" == "$option" ]
}


_'"$SCRIPT_NAME"'-cache-branch-names()
{
	local completion_source_patterns_path=$1
	local cache_path=$2

	if [ ! "$cache_path" -ot "$completion_source_patterns_path" ]
	then
		return
	fi

	local path_pattern_options=()
	local pattern
	while read -r pattern
	do
		if [ ${#path_pattern_options[@]} \> 0 ]
		then
			path_pattern_options+=("-or")
		fi

		path_pattern_options+=("-path" "${pattern:1:${#pattern}-2}")
	done < <(grep "^[^#][^ ]+$" "$completion_source_patterns_path" | sed -e "s/^/\"/" -e "s/$/\"/")

	local git_dirs=($(find . "(" "${path_pattern_options[@]}" ")" -type d -name ".git"))
	local project_paths=()
	local git_dir
	for git_dir in "${git_dirs[@]}"
	do
		project_paths+=("$(dirname "$git_dir")")
	done

	printf "%s\n" "${project_paths[@]}" > "$cache_path"
}


_'"$SCRIPT_NAME"'-branch-list()
{
	local git_branch_command=$1
	local completion_source_patterns_file_name=$2

	local completion_source_patterns_path
	completion_source_patterns_path=$(_'"$SCRIPT_NAME"'-config-path-for-file "$completion_source_patterns_file_name")
	if [ $? != 0 ]
	then
		return
	fi

	_'"$SCRIPT_NAME"'-cache-branch-names "$completion_source_patterns_path" "$_'"$SCRIPT_NAME"'_COMPLETION_SOURCE_PROJECT_PATHS"
	if [ ! -r "$completion_source_patterns_path" ]
	then
		return
	fi

	local branches=()
	local path
	while read -r path
	do
		branches+=($(cd "$path"; $git_branch_command $git_branch_option | grep -v "HEAD detached at" | sed -e "s/* //" -e "s/  //"))
	done < <(cat "$_'"$SCRIPT_NAME"'_COMPLETION_SOURCE_PROJECT_PATHS")

	local tokens=()
	local branch
	for branch in "${branches[@]}"
	do
		local components
		IFS="/" read -ra components <<< "$branch"

		tokens+=("${components[@]}")
	done
	branches+=("${tokens[@]}")

	printf "%s\n" "${branches[@]}" | sort | uniq
}


_'"$SCRIPT_NAME"'-completion()
{
	if [ $COMP_CWORD == 1 ]
	then
		local ACTIONS=('"${SCRIPT_ACTIONS[@]}"')
		local custom_actions_path
		custom_actions_path=$(_'"$SCRIPT_NAME"'-config-path-for-file "$_'"$SCRIPT_NAME"'_CUSTOM_ACTIONS_FILE_NAME")
		if [ $? == 0 ]
		then
			local line
			while read -r line
			do
				local action="${line%% *}"
				ACTIONS+=("$action")
			done < <(grep -e "^\s*[^#][a-zA-Z0-9]\+.*" "$custom_actions_path")
		fi

		COMPREPLY=($(compgen -W "${ACTIONS[*]}" "${COMP_WORDS[1]}"))
		return
	fi

	local argument="${COMP_WORDS[$COMP_CWORD-1]}"

	if [ "$argument" == "--project" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "p"
	then
		if [ ! -r "$_'"$SCRIPT_NAME"'_COMPLETION_PROJECT_LIST_PATH" ]
		then
			return
		fi

		local projects=$(cat "$_'"$SCRIPT_NAME"'_COMPLETION_PROJECT_LIST_PATH")
		COMPREPLY=($(compgen -W "$projects" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if [ "$argument" == "--branch" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "B"
	then
		local branches
		branches=$(_'"$SCRIPT_NAME"'-branch-list "git rev-parse --abbrev-ref HEAD" "$_'"$SCRIPT_NAME"'_COMPLETION_SOURCE_PATTERNS_FILE_NAME")
		if [ $? != 0 ]
		then
			return
		fi

		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if [ "$argument" == "--branches" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "b"
	then
		local branches
		branches=$(_'"$SCRIPT_NAME"'-branch-list "git branch" "$_'"$SCRIPT_NAME"'_COMPLETION_SOURCE_PATTERNS_FILE_NAME")
		if [ $? != 0 ]
		then
			return
		fi

		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if [ "$argument" == "--remote-branches" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "r"
	then
		local branches
		branches=$(_'"$SCRIPT_NAME"'-branch-list "git branch --remotes" "$_'"$SCRIPT_NAME"'_COMPLETION_SOURCE_PATTERNS_FILE_NAME")
		if [ $? != 0 ]
		then
			return
		fi

		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if [ "$argument" == "--all-branches" ] || _'"$SCRIPT_NAME"'-is-short-option "$argument" "a"
	then
		local branches
		branches=$(_'"$SCRIPT_NAME"'-branch-list "git branch --all" "$_'"$SCRIPT_NAME"'_COMPLETION_SOURCE_PATTERNS_FILE_NAME")
		if [ $? != 0 ]
		then
			return
		fi

		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi
}


complete -F _'"$SCRIPT_NAME"'-completion '"$SCRIPT_NAME"


MATCHERS=()
MATCHER_PREFIXES=()
MATCH_FUNCTIONS=()
MATCHER_PATTERNS=()

PROMPT_TO_USE_REPOSITORY_FUNCTION=nothing
DEAL_WITH_FAILED_COMMAND_FUNCTION=deal-with-failed-command-manually
OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-shell
FOREACH_ARGUMENTS=()
PRINT_MESSAGE_BACKEND=printf-message-default
PRINT_INTERACTION_BACKEND=printf-interaction-default
PRINT_WARNING_BACKEND=printf-warning-default
PRINT_ERROR_BACKEND=printf-error-default
DO_JOB_FUNCTION=pick-project-and-perform-action
PERFORM_ACTION_FUNCTION=''
ABORT_OPEN_ACTION_EXIT_STATUS=66


#
# Options

OPTION_ACTION=''
OPTION_WORKSPACE_PATH=''
OPTION_NEGATE_NEXT_PATTERN=false
OPTION_NEGATE_ALL_PATTERNS=false
OPTION_STRICT_NEXT_PATTERN=false
OPTION_STRICT_ALL_PATTERNS=false
OPTION_UNCOMMITED=false
OPTION_IGNORE_DETACHED=false
OPTION_TERMINAL_TABS=false
OPTION_APPLE_TERMINAL=false
OPTION_GNOME_TERMINAL=false
OPTION_ITERM=false
OPTION_TMUX=false
OPTION_INTERACTIVE=false
OPTION_IGNORE_FAILED=false


#
# Option dependent functions

prompt-user-to-select-project()
{
	"$PROMPT_TO_USE_REPOSITORY_FUNCTION" "$@"
}


deal-with-failed-command()
{
	"$DEAL_WITH_FAILED_COMMAND_FUNCTION" "$@"
}


open-projects()
{
	"$OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION" "$@"
}


do-job()
{
	"$DO_JOB_FUNCTION" "$@"
}


perform-action()
{
	"$PERFORM_ACTION_FUNCTION" "$@"
}


#
# git pretty

repository-current-branch-pretty()
{
	local path=$1

	local output=$(cd "$path"; git -c color.ui=always branch | grep '^\* ')
	printf '%s\n' "${output}"
}


repository-branch-list-pretty()
{
	local path=$1

	local output=$(cd "$path"; git -c color.ui=always branch --all)
	printf '%s\n' "$output"
}


repository-status-pretty()
{
	local path=$1

	local project_name=$(basename "$path")
	local status=$(cd "$path"; git -c color.ui=always status)

	printf '\e[1;4m%s\e[0m\n%s\n' "$project_name" "$status"
}


#
# git raw

repository-current-branch()
{
	local path=$1

	local output=$(cd "$path"; git branch | grep -v 'HEAD detached at' | grep '^\* ')
	printf '%s\n' "${output##\* }"
}


repository-local-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-remote-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch --remote | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch --all | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-has-detached-head()
{
	local path=$1

	$(cd "$path"; git symbolic-ref HEAD > /dev/null 2>&1)
	[ $? != 0 ]
}


#
# Matcher functions

add-matcher()
{
	local matcher=$1
	local pattern=$2

	MATCHERS+=("$matcher")

	if $OPTION_NEGATE_NEXT_PATTERN
	then
		MATCHER_PREFIXES+=('negate')
		OPTION_NEGATE_NEXT_PATTERN=false
	else
		MATCHER_PREFIXES+=('straight')
	fi

	if $OPTION_STRICT_NEXT_PATTERN
	then
		MATCH_FUNCTIONS+=('strict-match')
		OPTION_STRICT_NEXT_PATTERN=false
	else
		MATCH_FUNCTIONS+=('inclusion-match')
	fi

	MATCHER_PATTERNS+=("$pattern")
}


straight()
{
	local value=$1

	[ $value == 0 ]
}


negate()
{
	local value=$1

	[ $value != 0 ]
}


inclusion-match()
{
	local string=$1
	local pattern=$2

	[[ $string == *$pattern* ]]
}


strict-match()
{
	local string=$1
	local pattern=$2

	[ "$string" == "$pattern" ]
}


matcher-project-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local project_name=$(basename "$project_path")
	"$match_function" "$project_name" "$pattern"
}


matcher-current-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branch=$(repository-current-branch "$project_path")
	"$match_function" "$branch" "$pattern"
}


matcher-local-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-local-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-remote-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-remote-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-all()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	matcher-project-name "$project_path" "$match_function" "$pattern" || \
	matcher-current-branch-name "$project_path" "$match_function" "$pattern" || \
	matcher-local-branch-name "$project_path" "$match_function" "$pattern"
}


matcher-uncommited-changes()
{
	local project_path=$1

	$(cd "$project_path"; git diff-index --quiet HEAD --)
	[ $? != 0 ]
}


matcher-head-attached()
{
	local project_path=$1

	! repository-has-detached-head "$project_path"
}


matcher-head-detached()
{
	local project_path=$1

	repository-has-detached-head "$project_path"
}


run-matchers()
{
	local project_path=$1

	local index
	for (( index = 0; index < ${#MATCHERS[@]}; ++index ))
	do
		local matcher="${MATCHERS[$index]}"
		local matcher_prefix="${MATCHER_PREFIXES[$index]}"
		local match_function="${MATCH_FUNCTIONS[$index]}"
		local pattern="${MATCHER_PATTERNS[$index]}"

		"$matcher" "$project_path" "$match_function" "$pattern"
		"$matcher_prefix" $?
		if [ $? != 0 ]
		then
			return 1
		fi
	done
}


#
# Stuff

nothing()
{
	:
}


command-exists()
{
	local name=$1

	command -v "$name" > /dev/null 2>&1
}


prompt-yes-no()
{
	local print_backend=$1

	"$print_backend" "${@:2}"
	while :
	do
		local action
		read action
		case $action in
			y)
				return 0
				;;

			n)
				return 1
				;;

			*)
				printf-interaction '\nType "y" or "n"\n'
			;;
		esac
	done
}


deal-with-failed-command-manually()
{
	local retval=$1
	local path=$2

	if [ $retval == 0 ]
	then
		return
	fi

	printf '\n'
	if prompt-yes-no printf-warning "command exited with non-zero code.\nDo you want to open this project in shell to deal with error and run your command manualy? (y/n) "
	then
		"$CURRENT_SHELL" -c "cd '$path'; $CURRENT_SHELL"
	fi
}


exclusive()
{
	local values=("$@")

	local true_count=( 0 )
	local value
	for value in "${values[@]}"
	do
		if $value
		then
			(( ++true_count ))
		fi
	done

	[ $true_count -le 1 ]
}


normalize-path()
{
	local path=$1
	$(cd "$path"; pwd)
}


string-trim-spaces()
{
    local string=$1

    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"
    printf '%s\n' "$string"
}


string-trim-quotes()
{
	local string=$1

	local first_char="${string:0:1}"
	if [ "$first_char" == "'" ] || [ "$first_char" == '"' ]
	then
		printf '%s\n' "${string:1:${#string}-2}"
	else
		printf '%s\n' "$string"
	fi
}


array-contains()
{
	local value=$1
	local array=("${@:2}")

	local item
	for item in "${array[@]}"
	do
		if [ "$item" == "$value" ]
		then
			return 0
		fi
	done

	return 1
}


array-fill()
{
	local size=$1
	local value=$2

	printf '%.0s\n' "$value" {1..${#MATCH_FUNCTIONS[@]}}
}


array-index-of()
{
	local value=$1
	local array=("${@:2}")

	local index=( 0 )
	local item
	for item in "${array[@]}"
	do
		if [ "$item" == "$value" ]
		then
			printf '%s\n' $index
			return
		fi

		(( ++index ))
	done

	return 1
}


#
# Configuration

config-path-for-file()
{
	local config_file=$1

	local path
	for path in "${CONFIG_DIR_PATHS[@]}"
	do
		if [ -r "$path/$config_file" ]
		then
			printf '%s/%s\n' "$path" "$config_file"
			return
		fi
	done

	return 1
}


config-first-path-to-store-file()
{
	local config_file=$1

	printf '%s/%s\n' "${CONFIG_DIR_PATHS[0]}" "$config_file"
}


custom-actions-config-get-action()
{
	local string=$1

	string-trim-spaces "${string%% *}"
}


custom-actions-config-get-options()
{
	local string=$1
	local action=$2

	string="${string#$action}"
	string-trim-spaces "${string%%--*}"
}


custom-actions-config-get-command()
{
	local string=$1

	string="${string#*-- }"
	string-trim-spaces "${string%#*}"
}


custom-actions-config-get-description()
{
	local string=$1

	[[ $string =~ ^.*#.*$ ]] && string-trim-spaces "${line#*#}"
}


#
# Actions

cache-project-paths()
{
	local cache_path=$1
	local workspace_path=$2

	# make '! -path <pattern>' options for 'find'
	local ignore_pattern_options=()
	local config_ignore_path
	config_ignore_path="$(config-path-for-file "$IGNORE_FILE_NAME")"
	if [ $? == 0 ]
	then
		local pattern
		while read -r pattern
		do
			if [ ${#ignore_pattern_options} \> 0 ]
			then
				ignore_pattern_options+=('-and')
			fi

			# removing quotes, so they are not part of the pattern
			ignore_pattern_options+=('!' '-path' "${pattern:1:${#pattern}-2}")
		done < <(grep '^[^#][^ ]*$' "$config_ignore_path" | sed -e 's/^/"/' -e 's/$/"/') # quoting patterns to prevent asterisk expansion
	fi

	# collect paths
	local git_dirs=($(find "$workspace_path" "${ignore_pattern_options[@]}" -type d -name '.git'))
	local project_paths=()
	local git_dir
	for git_dir in "${git_dirs[@]}"
	do
		project_paths+=("$(dirname "$git_dir")")
	done

	printf '%s\n' "${project_paths[@]}" > "$cache_path"
}


cache-project-names()
{
	local cache_path=$1
	local project_paths=("${@:2}")

	# collect project names
	local project_list=()
	local project_path
	for project_path in "${project_paths[@]}"
	do
		local project_name=$(basename "$project_path")
		project_list+=("$project_name")
	done

	# split project names into tokens and store them with project names
	local parts=()
	local project_name
	for project_name in "${project_list[@]}"
	do
		local tokens
		IFS='.-_ ' read -ra tokens <<< "$project_name"
		parts+=("${tokens[@]}")
	done
	project_list+=("${parts[@]}")

	printf '%s\n' "${project_list[@]}" | sort | uniq > "$cache_path"
}


prompt-user-to-select-project-implementation()
{
	local project_path=$1
	local prompt=$2

	repository-status-pretty "$project_path"
	printf '\n'
	prompt-yes-no printf-interaction "$prompt"
}


show-repositories-status()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		repository-status-pretty "$path"
		printf '\n'
	done
}


list-repositories()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		local project_name=$(basename "$path")
		printf '\e[1m%s\e[0m -- %s\n' "$project_name" "$path"
	done
	printf '\n'
}


start-shell()
{
	local project_paths=("$@")

	local path
	for path in "${project_paths[@]}"
	do
		if ! prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			continue
		fi

		local project_name=$(basename "$path")
		printf '\e[1;4m%s\e[0m\n' "$project_name"
		"$CURRENT_SHELL" -c "cd '$path'; $CURRENT_SHELL"
		if [ $? == $ABORT_OPEN_ACTION_EXIT_STATUS ]
		then
			if prompt-yes-no printf-warning 'shell exited with abort open action exit status (%s). Do you want to stop opening projects? (y/n) ' "$ABORT_OPEN_ACTION_EXIT_STATUS"
			then
				break
			fi
		fi

		printf '\n'
	done
}


start-gnome-terminal()
{
	if ! command-exists 'gnome-terminal'
	then
		printf-error 'gnome-terminal is not installed'
		return 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	local gnome_terminal_options=()
	for path in "${selected_paths[@]}"
	do
		gnome_terminal_options+=("--tab --working-directory ${path}")
	done

	gnome-terminal ${gnome_terminal_options[@]}
}


start-apple-terminal()
{
	local project_paths=("$@")

	local project
	for path in "${project_paths[@]}"
	do
		osascript \
			-e 'tell application "Terminal" to activate' \
			-e 'tell application "System Events" to tell process "Terminal" to keystroke "t" using command down' \
			-e 'tell application "Terminal" to do script "cd '"'$path'"'" in selected tab of the front window' > /dev/null
	done
}


start-iterm()
{
	local project_paths=("$@")

	local project
	for path in "${project_paths[@]}"
	do
		osascript \
			-e 'tell application "iTerm"
					tell current window
						create tab with default profile
					end tell
					tell current tab of current window
						set _new_session to last item of sessions
					end tell
					tell _new_session
						select
						write text "cd '"'$path'"'"
					end tell
				end tell' > /dev/null
	done
}


start-tmux()
{
	if ! command-exists 'tmux'
	then
		printf-error 'tmux is not installed'
		return 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	local session_name=$(basename "$WORKSPACE_PATH")
	tmux new-session -d -s "$session_name" -c "${selected_paths[0]}"

	for path in "${selected_paths[@]:1}"
	do
		tmux split-window -v -p 50 -c "${path}"
		tmux select-layout tiled
	done

	tmux -2 attach-session -t "$session_name"
}


continue-tmux()
{
	if ! command-exists 'tmux'
	then
		printf-error 'tmux is not installed'
		return 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	tmux new-window -c "${selected_paths[0]}"

	for path in "${selected_paths[@]:1}"
	do
		tmux split-window -v -p 50 -c "${path}"
		tmux select-layout tiled
	done
}


foreach-project()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		if $OPTION_INTERACTIVE
		then
			if ! prompt-user-to-select-project "$path" 'Run your command with this repository? (y/n)'
			then
				printf '\n'
				continue
			fi
		else
			local project_name=$(basename "$path")
			printf '\e[1;4m%s\e[0m\n' "$project_name"
		fi

		bash -c "cd '$path'; ${FOREACH_ARGUMENTS[*]}"
		deal-with-failed-command $? "$path"
		printf '\n'
	done
}


foreach-project-git()
{
	FOREACH_ARGUMENTS=('git' ${FOREACH_ARGUMENTS[@]})
	foreach-project "$@"
}


#
# Jobs

show-help()
{
	local custom_action_help=''
	local index
	for (( index = 0; index < ${#CUSTOM_ACTIONS[@]}; ++index ))
	do
		local action=$(printf '%*s' -11 "${CUSTOM_ACTIONS[$index]}")
		local description="${CUSTOM_ACTIONS_DESCRIPTIONS[$index]}"
		if [ -z "$description" ]
		then
			if [ -n "${CUSTOM_ACTIONS_OPTIONS[$index]}" ]
			then
				local options="${CUSTOM_ACTIONS_OPTIONS[$index]} "
			else
				local options=''
			fi

			description="\$ $SCRIPT_NAME $options[<...>] -- ${CUSTOM_ACTIONS_COMMANDS[$index]} [<...>]"
		fi

		custom_action_help+="  $action $description\n"
	done

	printf \
"\e[1mUSAGE\e[0m
  $SCRIPT_NAME <action> [<options>...]

\e[1mACTIONS\e[0m
  status      show git status for projects.
  list        list projects.
  git         run git command for each project.
  foreach     run command for each project.
  open        open projects in shell (default), terminal tabs or tmux panels.
$custom_action_help
\e[1mOPTIONS\e[0m
  -W | --workspace-path <path>      Search path [default: current directory].
  -p | --project <pattern>          Project name pattern.
  -B | --branch <pattern>           Current branch name pattern.
  -b | --branches <pattern>         Branch name pattern for local branches.
  -r | --remote-branches <pattern>  Branch name pattern for remote branches.
  -a | --all-branches <pattern>     Branch name pattern for all branches.
  -s | --strict                     Match next pattern strictly.
  -S | --strict-all                 Match all patterns strictly.
  -n | --negate                     Negate next pattern.
  -N | --negate-all                 Negate all patterns.
  -u | --uncommited                 Match projects with uncommited changes.
  -d | --ignore-detached            Do not match projects with detached HEAD.
  -t | --tabs                       Open projects in current terminal tabs/panels.
  -A | --apple-terminal             Open projects in Apple terminal tabs.
  -G | --gnome-terminal             Open projects in Gnome terminal tabs.
  -I | --iterm                      Open projects in iTerm tabs.
  -X | --tmux                       Open projects in tmux panels.
  -i | --interactive                Chose projects to do your stuff with.
  -g | --ignore-failed              Do not prompt to deal with error for failed commands in 'git' and 'foreach'.
  --abort-open <0..127>             Abort 'open' action with exit status [default: 66].

  --print-message <command>         Print message with command.
  --print-interaction <command>     Print interactions with command.
  --print-warrning <command>        Print warning with command.
  --print-error <command>           Print message with command.
  --colored-messages                Use colored output for messages.
  --colored-interactions            Use colored output for interactions.
  --colored-errors                  Use colored output for errors.

  -h | --help                       Show this message.

\e[1mADDITIONAL COMMANDS\e[0m
  install-completion-script  Install bash completion script for project and branch names.
  cache-workspace-info       Update project paths cache.

\e[1mMore info at \e[4mhttps://github.com/shrpnsld/workspace\e[0m

"
}


pick-project-and-perform-action()
{
	if [ ! -r "$CACHE_PROJECT_PATHS_PATH" ]
	then
		cache-workspace-info
		if [ $? != 0 ]
		then
			return 1
		fi
	fi

	project_paths=($(cat "$CACHE_PROJECT_PATHS_PATH"))
	project_count="${#project_paths[@]}"
	if [ $project_count == 0 ]
	then
		printf-error 'no projects found'
		return 1
	fi

	printf-message 'Scanning projects...'
	matched_projects=()
	for (( index = 0; ; ++index ))
	do
		print-progress-string $index $project_count

		if [ $index == $project_count ]
		then
			break;
		fi

		project_path="${project_paths[$index]}"
		if [ ! -d "$project_path" ]
		then
			# mark cache as outdated
			continue
		fi

		run-matchers "$project_path"
		if [ $? != 0 ]
		then
			continue
		fi

		matched_projects+=("$project_path")
	done

	printf '\n\n'

	if [ "${#matched_projects[@]}" == 0 ]
	then
		printf-message 'no matching projects found'
		return
	fi

	perform-action "${matched_projects[@]}"
	printf-message 'Done.'
}


install-completion-script()
{
	local bash_completion_dir='/etc/bash_completion.d/'
	if ! [ -w "$bash_completion_dir" ]
	then
		printf-error 'permission denied'
		return 1
	fi

	printf '%s\n' "$BASH_COMPLETION_SCRIPT" > "$bash_completion_dir/$SCRIPT_NAME"
	printf-message 'please restart shell'
}


cache-workspace-info()
{
	mkdir -p "$CACHE_DIR_PATH"
	if [ $? != 0 ]
	then
		printf-error 'failed to create "%s" directory' "$CACHE_DIR_PATH"
		return 1
	fi

	mkdir -p "$COMPLETION_DIR_PATH"
	if [ $? != 0 ]
	then
		printf-error 'failed to create "%s" directory' "$COMPLETION_DIR_PATH"
		return 1
	fi

	cache-project-paths "$CACHE_PROJECT_PATHS_PATH" "$WORKSPACE_PATH"

	local project_paths=($(cat "$CACHE_PROJECT_PATHS_PATH"))
	cache-project-names "$COMPLETION_PROJECT_LIST_PATH" "${project_paths[@]}"

	printf-message 'Done.'
}


#
# Parameters and options parsing/validating

PARAM_TYPE_SHORT_OPTION_LIST=1
PARAM_TYPE_LONG_OPTION=2
PARAM_TYPE_DELIMITER=3
PARAM_TYPE_STRING=4
PARAM_TYPE_BAD_PARAMETER=255

check-parameter()
{
	local string=$1

	if [ "${string:0:3}" == '--' ] && [ "${#string}" == 2 ]
	then
		return $PARAM_TYPE_DELIMITER
	fi

	if [ "${string:0:2}" == '--' ]
	then
		printf '%s\n' "${string#--}"
		return $PARAM_TYPE_LONG_OPTION
	fi

	if [ "${string:0:1}" == '-' ]
	then
		printf '%s\n' "${string#-}"
		return $PARAM_TYPE_SHORT_OPTION_LIST
	fi

	printf "$string"
	return $PARAM_TYPE_STRING

#	printf "$string"
#	return $PARAM_TYPE_BAD_PARAMETER
}


PARSE_OPTION_UNKNOWN_OPTION=255

parse-option()
{
	local option=$1
	local value=$2

	case "$option" in
		W|workspace-path)
			OPTION_WORKSPACE_PATH="$value"
			return 1
			;;

		p|project)
			add-matcher 'matcher-project-name' "$value"
			return 1
			;;

		B|branch)
			add-matcher 'matcher-current-branch-name' "$value"
			return 1
			;;

		b|branches)
			add-matcher 'matcher-local-branch-name' "$value"
			return 1
			;;

		r|remote-branches)
			add-matcher 'matcher-remote-branch-name' "$value"
			return 1
			;;

		a|all-branches)
			add-matcher 'matcher-branch-name' "$value"
			return 1
			;;

		s|strict)
			OPTION_STRICT_NEXT_PATTERN=true
			;;

		S|strict-all)
			OPTION_STRICT_ALL_PATTERNS=true
			;;

		n|negate)
			OPTION_NEGATE_NEXT_PATTERN=true
			;;

		N|negate-all)
			OPTION_NEGATE_ALL_PATTERNS=true
			;;

		u|uncommited)
			OPTION_UNCOMMITED=true
			;;

		d|ignore-detached)
			OPTION_IGNORE_DETACHED=true
			;;

		t|tabs)
			OPTION_TERMINAL_TABS=true
			;;

		A|apple-terminal)
			OPTION_APPLE_TERMINAL=true
			;;

		G|gnome-terminal)
			OPTION_GNOME_TERMINAL=true
			;;

		I|iterm)
			OPTION_ITERM=true
			;;

		X|tmux)
			OPTION_TMUX=true
			;;

		i|interactive)
			OPTION_INTERACTIVE=true
			;;

		g|ignore-failed)
			OPTION_IGNORE_FAILED=true
			;;

		color)
			OPTIONAL_INTERACTION_STYLE_BEGIN="$TEXT_STYLE_INTERACTION"
			OPTIONAL_INTERACTION_STYLE_END="$TEXT_STYLE_NORMAL"
			OPTIONAL_WARNING_STYLE_BEGIN="$TEXT_STYLE_WARNING"
			OPTIONAL_WARNING_STYLE_END="$TEXT_STYLE_NORMAL"
			OPTIONAL_ERROR_STYLE_BEGIN="$TEXT_STYLE_ERROR"
			OPTIONAL_ERROR_STYLE_END="$TEXT_STYLE_NORMAL"
			;;

		interaction-color)
			OPTIONAL_INTERACTION_STYLE_BEGIN="$TEXT_STYLE_INTERACTION"
			OPTIONAL_INTERACTION_STYLE_END="$TEXT_STYLE_NORMAL"
			;;

		warning-color)
			OPTIONAL_WARNING_STYLE_BEGIN="$TEXT_STYLE_WARNING"
			OPTIONAL_WARNING_STYLE_END="$TEXT_STYLE_NORMAL"
			;;

		error-color)
			OPTIONAL_ERROR_STYLE_BEGIN="$TEXT_STYLE_ERROR"
			OPTIONAL_ERROR_STYLE_END="$TEXT_STYLE_NORMAL"
			;;

		no-color)
			OPTIONAL_INTERACTION_STYLE_BEGIN=''
			OPTIONAL_INTERACTION_STYLE_END=''
			OPTIONAL_WARNING_STYLE_BEGIN=''
			OPTIONAL_WARNING_STYLE_END=''
			OPTIONAL_ERROR_STYLE_BEGIN=''
			OPTIONAL_ERROR_STYLE_END=''
			;;

		no-interaction-color)
			OPTIONAL_INTERACTION_STYLE_BEGIN=''
			OPTIONAL_INTERACTION_STYLE_END=''
			;;

		no-warning-color)
			OPTIONAL_WARNING_STYLE_BEGIN=''
			OPTIONAL_WARNING_STYLE_END=''
			;;

		no-error-color)
			OPTIONAL_ERROR_STYLE_BEGIN=''
			OPTIONAL_ERROR_STYLE_END=''
			;;

		print-message)
			local backend=$(string-trim-quotes "$value")
			if bash -c "$backend test" &> /dev/null
			then
				PRINT_MESSAGE_BACKEND="$backend"
			fi
			return 1
			;;

		print-interaction)
			local backend=$(string-trim-quotes "$value")
			if bash -c "$backend test" &> /dev/null
			then
				PRINT_INTERACTION_BACKEND="$backend"
			fi
			return 1
			;;


		print-warning)
			local backend=$(string-trim-quotes "$value")
			if bash -c "$backend test" &> /dev/null
			then
				PRINT_WARNING_BACKEND="$backend"
			fi
			return 1
			;;

		print-error)
			local backend=$(string-trim-quotes "$value")
			if bash -c "$backend test" &> /dev/null
			then
				PRINT_ERROR_BACKEND="$backend"
			fi
			return 1
			;;

		abort-open)
			ABORT_OPEN_ACTION_EXIT_STATUS=$value
			return 1
			;;

		*)
			return $PARSE_OPTION_UNKNOWN_OPTION
			;;
	esac
}


parse-action()
{
	local action=$1

	case "$action" in
		''|-h|--help)
			DO_JOB_FUNCTION=show-help
			;;

		cache-workspace-info)
			DO_JOB_FUNCTION=cache-workspace-info
			;;

		install-completion-script)
			DO_JOB_FUNCTION=install-completion-script
			;;

		*)
			if ! array-contains "$action" "${SCRIPT_ACTIONS[@]}" "${CUSTOM_ACTIONS[@]}"
			then
				return 1
			fi

			OPTION_ACTION="$action"
			;;
	esac
}


parse-parameters()
{
	local parameters=("$@")

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter=$(check-parameter "${parameters[$parameter_index]}")
		local parameter_type=$?
		if [ $parameter_type == $PARAM_TYPE_STRING ]
		then
			add-matcher 'matcher-all' "$parameter"
		fi

		#if [ $parameter_type == $PARAM_TYPE_BAD_PARAMETER ]
		#then
		#	printf-error 'bad parameter "%s"' "$parameter"
		#	return 1
		#fi

		case $parameter_type in
			$PARAM_TYPE_SHORT_OPTION_LIST)
				local value="${parameters[$parameter_index + 1]}"

				local index
				for (( index = 0; index < ${#parameter}; ++index ))
				do
					local option="${parameter:$index:1}"
					parse-option "$option" "$value"
					local retval=$?
					case $retval in
						$PARSE_OPTION_UNKNOWN_OPTION)
							printf-error 'unknown option "%s"' "$option"
							return 1
							;;

						*)
							(( parameter_index += retval ))
							;;
					esac
				done

				continue
				;;

			$PARAM_TYPE_LONG_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				parse-option "$parameter" "$value"
				(( parameter_index += $? ))
				continue
				;;

			$PARAM_TYPE_DELIMITER)
				(( ++parameter_index ))
				break
				;;
		esac
	done

	if [ $parameter_index == ${#parameters[@]} ]
	then
		return
	fi

	if [ $parameter_type == $PARAM_TYPE_DELIMITER ]
	then
		for (( ; parameter_index < ${#parameters[@]}; ++parameter_index ))
		do
			local parameter="${parameters[$parameter_index]}"
			FOREACH_ARGUMENTS+=("$parameter")
		done
	fi
}


validate-options()
{
	local action=$1

	case $action in
		status|list)
			if $OPTION_TERMINAL_TABS || $OPTION_APPLE_TERMINAL || $OPTION_GNOME_TERMINAL || $OPTION_ITERM || $OPTION_TMUX
			then
				printf-error '"-t", "--tabs", "--apple-terminal", "--gnome-terminal" or "--iterm" should be used with "open" action'
				return 1
			fi

			if $OPTION_INTERACTIVE
			then
				printf-error '"-i" ("--interactive") should be used with "open", "foreach" or "git" action'
				return 1
			fi

			if $OPTION_IGNORE_FAILED
			then
				printf-error '"-g" ("--ignore-failed") should be used with "foreach" or "git" action'
				return 1
			fi
			;;

		open)
			if $OPTION_IGNORE_FAILED
			then
				printf-error '"-g" ("--ignore-failed") should be used with "foreach" or "git" action'
				return 1
			fi
			;;

		git|foreach)
			if $OPTION_TERMINAL_TABS || $OPTION_APPLE_TERMINAL || $OPTION_GNOME_TERMINAL || $OPTION_ITERM || $OPTION_TMUX
			then
				printf-error '"-t", "--tabs", "--apple-terminal", "--gnome-terminal" or "--iterm" should be used with "open" action'
				return 1
			fi
			;;
	esac

	if ! exclusive $OPTION_TERMINAL_TABS $OPTION_APPLE_TERMINAL $OPTION_GNOME_TERMINAL $OPTION_ITERM $OPTION_TMUX
	then
		printf-error 'you can'"'"'t specify both Gnome Terminal tabs and tmux panels'
		return 1
	fi

	if [ -n "$OPTION_WORKSPACE_PATH" ] && [ ! -d "$OPTION_WORKSPACE_PATH" ]
	then
		printf-error "'"'%s'"'"' does not exist' "$OPTION_WORKSPACE_PATH"
		return 1
	fi

	current-terminal-application
	local retval=$?
	if [ $retval == $TERMINAL_APPLICATION_UNKNOWN ]
	then
		printf-error 'failed to detect terminal application, or terminal is not supported. Specify it explicitly: -A, -G, -I, -X'
		return 1
	fi

	CURRENT_TERMINAL_APPLICATION=$retval
}


apply-parameters()
{
	case $OPTION_ACTION in
		status)
			PERFORM_ACTION_FUNCTION=show-repositories-status
			;;

		list)
			PERFORM_ACTION_FUNCTION=list-repositories
			;;

		open)
			PERFORM_ACTION_FUNCTION=open-projects
			;;

		git)
			PERFORM_ACTION_FUNCTION=foreach-project-git
			;;

		foreach)
			PERFORM_ACTION_FUNCTION=foreach-project
			;;

		*)
			PERFORM_ACTION_FUNCTION=foreach-project
			local index=$(array-index-of "$OPTION_ACTION" "${CUSTOM_ACTIONS[@]}")
			FOREACH_ARGUMENTS=("${CUSTOM_ACTIONS_COMMANDS[$index]}" "${FOREACH_ARGUMENTS[@]}")
			;;
	esac

	if [ -n "$OPTION_WORKSPACE_PATH" ]
	then
		WORKSPACE_PATH=$(normalize-path "$OPTION_WORKSPACE_PATH")
	fi

	if $OPTION_UNCOMMITED
	then
		MATCHERS+=('matcher-uncommited-changes')
		MATCHER_PREFIXES+=('straight')
		MATCH_FUNCTIONS+=('inclusion-match')
		MATCHER_PATTERNS+=('')
	fi

	if $OPTION_IGNORE_DETACHED
	then
		MATCHERS+=('matcher-head-attached')
		MATCHER_PREFIXES+=('straight')
		MATCH_FUNCTIONS+=('inclusion-match')
		MATCHER_PATTERNS+=('')
	fi

	if $OPTION_NEGATE_ALL_PATTERNS
	then
		MATCH_PREFIXES=($(array-fill ${#MATCH_FUNCTIONS[@]} 'negate'))
	fi

	if $OPTION_STRICT_ALL_PATTERNS
	then
		MATCH_FUNCTIONS=($(array-fill ${#MATCH_FUNCTIONS[@]} 'strict-match'))
	fi

	if $OPTION_TERMINAL_TABS
	then
		case $CURRENT_TERMINAL_APPLICATION in
			$TERMINAL_APPLICATION_APPLE)
				OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-apple-terminal
				;;

			$TERMINAL_APPLICATION_ITERM)
				OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-iterm
				;;

			$TERMINAL_APPLICATION_GNOME)
				OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-gnome-terminal
				;;

			$TERMINAL_APPLICATION_TMUX)
				OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=continue-tmux
				;;
		esac
	elif $OPTION_APPLE_TERMINAL
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-apple-terminal
	elif $OPTION_GNOME_TERMINAL
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-gnome-terminal
	elif $OPTION_ITERM
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-iterm
	elif $OPTION_TMUX
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-tmux
	fi

	if $OPTION_INTERACTIVE
	then
		PROMPT_TO_USE_REPOSITORY_FUNCTION=prompt-user-to-select-project-implementation
	fi

	if $OPTION_IGNORE_FAILED
	then
		DEAL_WITH_FAILED_COMMAND_FUNCTION=nothing
	fi
}


#
# Progress

PROGRESS_BAR_CHARACTER='#'
PROGRESS_BAR_SIZE=20
PROGRESS_BAR_FILL=$(printf "$PROGRESS_BAR_CHARACTER"'%.0s' $(seq 1 $PROGRESS_BAR_SIZE))

make-progress-string()
{
	local current=$1
	local total=$2

	local percentage=$(( current * 100 / total ))
	local current_length=$(( percentage * PROGRESS_BAR_SIZE / 100 ))
	local fill="${PROGRESS_BAR_FILL:$PROGRESS_BAR_SIZE-$current_length}"
	printf '[%*s] % 3s%% (%*s/%s)' -$PROGRESS_BAR_SIZE "$fill" "$percentage" ${#total} $current $total
	return $current_length
}


print-progress-string()
{
	local current=$1
	local total=$2

	progress_string=$(make-progress-string $current $total)
	printf '\r%s' "$progress_string"
}


#
# Custom commands

custom_actions_path="$(config-path-for-file "$CUSTOM_ACTIONS_FILE_NAME")"
if [ $? == 0 ]
then
	while read -r line
	do
		action=$(custom-actions-config-get-action "$line")
		cmd=$(custom-actions-config-get-command "$line")
		options=$(custom-actions-config-get-options "$line" "$action")
		description=$(custom-actions-config-get-description "$line")

		CUSTOM_ACTIONS+=("$action")
		CUSTOM_ACTIONS_OPTIONS+=("$options")
		CUSTOM_ACTIONS_COMMANDS+=("$cmd")
		CUSTOM_ACTIONS_DESCRIPTIONS+=("$description")
	done < <(grep -e '^\s*[^#]' "$custom_actions_path")
fi


#
# Script parameters

implicit_arguments=()
implicit_arguments_path=$(config-path-for-file "$IMPLICIT_ARGUMENTS_FILE_NAME")
if [ $? == 0 ]
then
	while read -r line
	do
		option="${line%% *}"
		value="${line#* }"
		implicit_arguments+=("$option" "$value")
	done < <(grep -e '^\s*[^#]' "$implicit_arguments_path")
fi

parse-parameters "${implicit_arguments[@]}"

#
# Sanity checks

if ! command-exists 'git'
then
	printf-error 'git is not installed'
	exit 1
fi


#
# Parameters

parse-action "$@"
if [ $? != 0 ]
then
	printf-error 'unknown action "%s"' "$1"
	exit 1
fi

parse-parameters "${@:2}" && validate-options "$1"
if [ $? != 0 ]
then
	exit 1
fi

apply-parameters


#
# Main

do-job

