#!/bin/bash

#
# Essentials

SCRIPT_NAME=$(basename $0)

RED_TEXT='\e[0;31m'
NO_STYLE_TEXT='\e[0m'
ERROR_PREFIX="$SCRIPT_NAME"' error:'

printf-error()
{
	printf "$ERROR_PREFIX" >&2
	printf " $@\n\n" >&2
}


printf-message()
{
	printf "$@\n"
}


if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	ERROR_PREFIX="$RED_TEXT$ERROR_PREFIX$NO_STYLE_TEXT"
fi


CURRENT_SHELL=$(ps -o comm= -p "$PPID")

WORKSPACE_PATH="$PWD"

CUSTOM_ACTIONS=()
CUSTOM_ACTIONS_OPTIONS=()
CUSTOM_ACTIONS_COMMANDS=()
CUSTOM_ACTIONS_DESCRIPTIONS=()

WORKSPACE_RC_DIR_NAME="$SCRIPT_NAME-script"

CUSTOM_ACTIONS_FILE_NAME='custom-actions'
IGNORE_FILE_NAME='ignore-paths'

LOCAL_WORKSPACE_RC_PATH="./.$WORKSPACE_RC_DIR_NAME"

CONFIG_DIR_PATHS=("$LOCAL_WORKSPACE_RC_PATH" "$HOME/.config/$WORKSPACE_RC_DIR_NAME" "/etc/$WORKSPACE_RC_DIR_NAME")

CACHE_DIR_PATH="$LOCAL_WORKSPACE_RC_PATH/cache"
CACHE_PROJECT_PATHS_PATH="$CACHE_DIR_PATH/project-paths"

COMPLETION_DIR_PATH="$LOCAL_WORKSPACE_RC_PATH/completion"
COMPLETION_PROJECT_LIST_PATH="$COMPLETION_DIR_PATH/project-list"
COMPLETION_CURRENT_BRANCH_LIST_PATH="$COMPLETION_DIR_PATH/current-branch-list"
COMPLETION_LOCAL_BRANCH_LIST_PATH="$COMPLETION_DIR_PATH/local-branch-list"
COMPLETION_REMOTE_BRANCH_LIST_PATH="$COMPLETION_DIR_PATH/remote-branch-list"
COMPLETION_BRANCH_LIST_PATH="$COMPLETION_DIR_PATH/branch-list"

SCRIPT_ACTIONS=('status' 'git' 'foreach' 'open' 'init' 'cache-workspace-info' 'install-completion-script')

BASH_COMPLETION_SCRIPT=\
'#!/bin/bash

_WORKSPACE_CONFIG_CUSTOM_ACTIONS_PATH='"$CONFIG_CUSTOM_ACTIONS_PATH"'
_WORKSPACE_COMPLETION_PROJECT_LIST_PATH='"$COMPLETION_PROJECT_LIST_PATH"'
_WORKSPACE_COMPLETION_CURRENT_BRANCH_LIST_PATH='"$COMPLETION_CURRENT_BRANCH_LIST_PATH"'
_WORKSPACE_COMPLETION_LOCAL_BRANCH_LIST_PATH='"$COMPLETION_LOCAL_BRANCH_LIST_PATH"'
_WORKSPACE_COMPLETION_REMOTE_BRANCH_LIST_PATH='"$COMPLETION_REMOTE_BRANCH_LIST_PATH"'
_WORKSPACE_COMPLETION_BRANCH_LIST_PATH='"$COMPLETION_BRANCH_LIST_PATH"'


_workspace-completion-is-short-option()
{
	local string=$1

	[ "${string:0:1}" == "-" ] && [ "${string:1:1}" != "-" ]
}


_workspace-completion()
{
	if [ $COMP_CWORD == 1 ]
	then
		local ACTIONS=('"${SCRIPT_ACTIONS[@]}"')
		if [ -r "$_WORKSPACE_CONFIG_CUSTOM_ACTIONS_PATH" ]
		then
			local line
			while read -r line
			do
				local action="${line%% *}"
				ACTIONS+=("$action")
			done < <(grep -e '"'"'^\s*[^#][a-zA-Z0-9]\+.*'"'"' "$_WORKSPACE_CONFIG_CUSTOM_ACTIONS_PATH")
		fi

		COMPREPLY=($(compgen -W "${ACTIONS[*]}" "${COMP_WORDS[1]}"))
		return
	fi

	local argument="${COMP_WORDS[$COMP_CWORD-1]}"

	if ([ "$argument" == "--project" ] \
		|| (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "p" ])) \
		&& [ -r "$_WORKSPACE_COMPLETION_PROJECT_LIST_PATH" ]
	then
		local projects=$(cat "$_WORKSPACE_COMPLETION_PROJECT_LIST_PATH")
		COMPREPLY=($(compgen -W "$projects" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if ([ "$argument" == "--branch" ] || (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "B" ])) \
		&& [ -r "$_WORKSPACE_COMPLETION_CURRENT_BRANCH_LIST_PATH" ]
	then
		local branches=$(cat "$_WORKSPACE_COMPLETION_CURRENT_BRANCH_LIST_PATH")
		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	elif ([ "$argument" == "--branches" ] || (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "b" ])) \
		&& [ -r "$_WORKSPACE_COMPLETION_LOCAL_BRANCH_LIST_PATH" ]
	then
		local branches=$(cat "$_WORKSPACE_COMPLETION_LOCAL_BRANCH_LIST_PATH")
		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	elif ([ "$argument" == "--remote-branches" ] || (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "r" ])) \
		&& [ -r "$_WORKSPACE_COMPLETION_REMOTE_BRANCH_LIST_PATH" ]
	then
		local branches=$(cat "$_WORKSPACE_COMPLETION_REMOTE_BRANCH_LIST_PATH")
		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	elif ([ "$argument" == "--all-branches" ] || (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "a" ])) \
		&& [ -r "$_WORKSPACE_COMPLETION_BRANCH_LIST_PATH" ]
	then
		local branches=$(cat "$_WORKSPACE_COMPLETION_BRANCH_LIST_PATH")
		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi
}

complete -F _workspace-completion '"$SCRIPT_NAME"

IGNORE_PATHS_FILE_COMMENT=\
'# glob patterns to ignore'

CUSTOM_ACTIONS_FILE_COMMENT=\
'# status -- git status # show git status for projects
'

MATCHERS=()
MATCHER_PREFIXES=()
MATCH_FUNCTIONS=()
MATCHER_PATTERNS=()

PROMPT_TO_USE_REPOSITORY_FUNCTION=nothing
DEAL_WITH_FAILED_COMMAND_FUNCTION=deal-with-failed-command-manually
OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-shell
FOREACH_ARGUMENTS=()
DO_JOB_FUNCTION=''


#
# Options

OPTION_ACTION=''
OPTION_WORKSPACE_PATH=''
OPTION_NEGATE_NEXT_PATTERN=false
OPTION_NEGATE_ALL_PATTERNS=false
OPTION_STRICT_NEXT_PATTERN=false
OPTION_STRICT_ALL_PATTERNS=false
OPTION_UNCOMMITED=false
OPTION_IGNORE_DETACHED=false
OPTION_TERMINAL_TABS=false
OPTION_APPLE_TERMINAL=false
OPTION_GNOME_TERMINAL=false
OPTION_ITERM=false
OPTION_TMUX=false
OPTION_INTERACTIVE=false
OPTION_IGNORE_FAILED=false


#
# Option dependent functions

prompt-user-to-select-project()
{
	"$PROMPT_TO_USE_REPOSITORY_FUNCTION" "$@"
}


deal-with-failed-command()
{
	"$DEAL_WITH_FAILED_COMMAND_FUNCTION" "$@"
}


open-projects()
{
	"$OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION" "$@"
}


do-job()
{
	"$DO_JOB_FUNCTION" "$@"
}


#
# git pretty

repository-current-branch-pretty()
{
	local path=$1

	local output=$(cd "$path"; git -c color.ui=always branch | grep '^\* ')
	printf '%s\n' "${output}"
}


repository-branch-list-pretty()
{
	local path=$1

	local output=$(cd "$path"; git -c color.ui=always branch --all)
	printf '%s\n' "$output"
}


repository-status-pretty()
{
	local path=$1

	local project_name=$(basename "$path")
	local status=$(cd "$path"; git -c color.ui=always status)

	printf '\e[1;4m%s\e[0m\n%s\n' "$project_name" "$status"
}


#
# git raw

repository-current-branch()
{
	local path=$1

	local output=$(cd "$path"; git branch | grep -v 'HEAD detached at' | grep '^\* ')
	printf '%s\n' "${output##\* }"
}


repository-local-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-remote-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch --remote | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch --all | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-has-detached-head()
{
	local path=$1

	$(cd "$path"; git symbolic-ref HEAD > /dev/null 2>&1)
	[ $? != 0 ]
}


#
# Matcher functions

add-matcher()
{
	local matcher=$1
	local pattern=$2

	MATCHERS+=("$matcher")

	if $OPTION_NEGATE_NEXT_PATTERN
	then
		MATCHER_PREFIXES+=('negate')
		OPTION_NEGATE_NEXT_PATTERN=false
	else
		MATCHER_PREFIXES+=('straight')
	fi

	if $OPTION_STRICT_NEXT_PATTERN
	then
		MATCH_FUNCTIONS+=('strict-match')
		OPTION_STRICT_NEXT_PATTERN=false
	else
		MATCH_FUNCTIONS+=('inclusion-match')
	fi

	MATCHER_PATTERNS+=("$pattern")
}


straight()
{
	local value=$1

	[ $value == 0 ]
}


negate()
{
	local value=$1

	[ $value != 0 ]
}


inclusion-match()
{
	local string=$1
	local pattern=$2

	[[ $string == *$pattern* ]]
}


strict-match()
{
	local string=$1
	local pattern=$2

	[ "$string" == "$pattern" ]
}


matcher-project-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local project_name=$(basename "$project_path")
	"$match_function" "$project_name" "$pattern"
}


matcher-current-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branch=$(repository-current-branch "$project_path")
	"$match_function" "$branch" "$pattern"
}


matcher-local-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-local-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-remote-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-remote-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-uncommited-changes()
{
	local project_path=$1

	$(cd "$project_path"; git diff-index --quiet HEAD --)
	[ $? != 0 ]
}


matcher-head-attached()
{
	local project_path=$1

	! repository-has-detached-head "$project_path"
}


matcher-head-detached()
{
	local project_path=$1

	repository-has-detached-head "$project_path"
}


run-matchers()
{
	local project_path=$1

	local index
	for (( index = 0; index < ${#MATCHERS[@]}; ++index ))
	do
		local matcher="${MATCHERS[$index]}"
		local matcher_prefix="${MATCHER_PREFIXES[$index]}"
		local match_function="${MATCH_FUNCTIONS[$index]}"
		local pattern="${MATCHER_PATTERNS[$index]}"

		"$matcher" "$project_path" "$match_function" "$pattern"
		"$matcher_prefix" $?
		if [ $? != 0 ]
		then
			return 1
		fi
	done
}


#
# Stuff

nothing()
{
	:
}


command-exists()
{
	local name=$1

	command -v "$name" > /dev/null 2>&1
}


prompt-yes-no()
{
	local prompt=$1

	while :
	do
		local action
		printf "$prompt "
		read action
		printf '\n'
		case $action in
			y)
				return 0
				;;

			n)
				return 1
				;;

			*)
				printf-message '\n\e[34mType "y" or "n"\e[0m'
			;;
		esac
	done
}


deal-with-failed-command-manually()
{
	local retval=$1
	local path=$2

	if [ $retval == 0 ]
	then
		return
	fi

	prompt-yes-no '\n\e[1;31mCommand exited with non-zero code.\nDo you want to open this project in shell to deal with error and run your command manualy? (y/n)\e[0m'
	if [ $? == 0 ]
	then
		"$CURRENT_SHELL" -c "cd '$path'; $CURRENT_SHELL"
	fi
}


exclusive()
{
	local values=("$@")

	local true_count=( 0 )
	local value
	for value in "${values[@]}"
	do
		if $value
		then
			(( ++true_count ))
		fi
	done

	[ $true_count -le 1 ]
}


normalize-path()
{
	local path=$1
	$(cd "$path"; pwd)
}


string-trim()
{
    local string=$1

    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"
    printf '%s\n' "$string"
}


array-contains()
{
	local value=$1
	local array=("${@:2}")

	local item
	for item in "${array[@]}"
	do
		if [ "$item" == "$value" ]
		then
			return 0
		fi
	done

	return 1
}


array-fill()
{
	local size=$1
	local value=$2

	printf '%.0s\n' "$value" {1..${#MATCH_FUNCTIONS[@]}}
}


array-index-of()
{
	local value=$1
	local array=("${@:2}")

	local index=( 0 )
	local item
	for item in "${array[@]}"
	do
		if [ "$item" == "$value" ]
		then
			printf '%s\n' $index
			return
		fi

		(( ++index ))
	done

	return 1
}


#
# Configuration

config-path-for-file()
{
	local config_file=$1

	local path
	for path in "${CONFIG_DIR_PATHS[@]}"
	do
		if [ -r "$path/$config_file" ]
		then
			printf '%s/%s\n' "$path" "$config_file"
			return
		fi
	done

	return 1
}


config-first-path-to-store-file()
{
	local config_file=$1

	printf '%s/%s\n' "${CONFIG_DIR_PATHS[0]}" "$config_file"
}


get-action()
{
	local string=$1

	string-trim "${string%% *}"
}


get-options()
{
	local string=$1
	local action=$2

	string="${string#$action}"
	string-trim "${string%%--*}"
}


get-command()
{
	local string=$1

	string="${string#*-- }"
	string-trim "${string%#*}"
}


get-description()
{
	local string=$1

	[[ $string =~ ^.*#.*$ ]] && string-trim "${line#*#}"
}


#
# Jobs

cache-project-paths()
{
	local cache_path=$1
	local workspace_path=$2

	local ignore_pattern_options=()

	# make '! -path <pattern>' options for 'find'
	local config_ignore_path
	config_ignore_path="$(config-path-for-file "$IGNORE_FILE_NAME")"
	if [ $? == 0 ]
	then
		# quoting patterns to prevent asterist expansion
		local ignored_patterns=($(grep '^[^#][^ ]*$' "$config_ignore_path" | sed -e 's/^/"/' -e 's/$/"/'))
		for pattern in "${ignored_patterns[@]}"
		do
			# removing quotes, so they are not part of the pattern
			ignore_pattern_options+=('!' '-path' "${pattern:1:${#pattern}-2}")
		done
	fi

	# collect paths
	local git_dirs=($(find "$workspace_path" "${ignore_pattern_options[@]}" -type d -name '.git'))
	local project_paths=()
	local git_dir
	for git_dir in "${git_dirs[@]}"
	do
		project_paths+=("$(dirname "$git_dir")")
	done

	printf '%s\n' "${project_paths[@]}" > "$cache_path"
}


cache-project-names()
{
	local cache_path=$1
	local project_paths=("${@:2}")

	# collect project names
	local project_list=()
	local project_path
	for project_path in "${project_paths[@]}"
	do
		local project_name=$(basename "$project_path")
		project_list+=("$project_name")
	done

	# split project names into tokens and store them with project names
	local parts=()
	local project_name
	for project_name in "${project_list[@]}"
	do
		local tokens
		IFS='.-_ ' read -ra tokens <<< "$project_name"
		parts+=("${tokens[@]}")
	done
	project_list+=("${parts[@]}")

	printf '%s\n' "${project_list[@]}" | sort | uniq > "$cache_path"
}


cache-branches()
{
	local cache_path=$1
	local branch_lister=$2
	local project_paths=("${@:3}")

	# collect branches
	local branch_list=()
	local path
	for path in "${project_paths[@]}"
	do
		branch_list+=($("$branch_lister" "$path"))
	done

	# split branch names into tokens and store them with branch names
	local tokens=()
	local branch
	for branch in "${branch_list[@]}"
	do
		local components
		IFS='/' read -ra components <<< "$branch"

		tokens+=("${components[@]}")
	done
	branch_list+=("${tokens[@]}")

	printf '%s\n' "${branch_list[@]}" | sort | uniq > "$cache_path"
}


cache-workspace-info()
{
	mkdir -p "$CACHE_DIR_PATH"
	if [ $? != 0 ]
	then
		printf-error 'failed to create "%s" directory' "$CACHE_DIR_PATH"
		return 1
	fi

	cache-project-paths "$CACHE_PROJECT_PATHS_PATH" "$WORKSPACE_PATH"

	mkdir -p "$COMPLETION_DIR_PATH"
	if [ $? != 0 ]
	then
		printf-error 'failed to create "%s" directory' "$COMPLETION_DIR_PATH"
		return 1
	fi

	local project_paths=($(cat "$CACHE_PROJECT_PATHS_PATH"))
	cache-project-names "$COMPLETION_PROJECT_LIST_PATH" "${project_paths[@]}"
	cache-branches "$COMPLETION_CURRENT_BRANCH_LIST_PATH" 'repository-current-branch' "${project_paths[@]}"
	cache-branches "$COMPLETION_LOCAL_BRANCH_LIST_PATH" 'repository-local-branch-list' "${project_paths[@]}"
	cache-branches "$COMPLETION_REMOTE_BRANCH_LIST_PATH" 'repository-remote-branch-list' "${project_paths[@]}"
	cache-branches "$COMPLETION_BRANCH_LIST_PATH" 'repository-branch-list' "${project_paths[@]}"
}


prompt-user-to-select-project-implementation()
{
	local project_path=$1
	local prompt=$2

	repository-status-pretty "$project_path"
	prompt-yes-no "\n\e[1;34m$prompt\e[0m"
}


show-repositories-status()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		repository-status-pretty "$path"
		printf '\n'
	done
}


start-shell()
{
	local project_paths=("$@")

	local path
	for path in "${project_paths[@]}"
	do
		if ! prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			continue
		fi

		local project_name=$(basename "$path")
		printf '\e[1;4m%s\e[0m\n' "$project_name"
		"$CURRENT_SHELL" -c "cd '$path'; $CURRENT_SHELL"
		printf '\n'
	done
}


start-gnome-terminal()
{
	if ! command-exists 'gnome-terminal'
	then
		printf-error 'gnome-terminal is not installed'
		exit 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	local gnome_terminal_options=()
	for path in "${selected_paths[@]}"
	do
		gnome_terminal_options+=("--tab --working-directory ${path}")
	done

	gnome-terminal ${gnome_terminal_options[@]}
}


start-apple-terminal()
{
	local project_paths=("$@")

	local project
	for path in "${project_paths[@]}"
	do
		osascript \
			-e 'tell application "Terminal" to activate' \
			-e 'tell application "System Events" to tell process "Terminal" to keystroke "t" using command down' \
			-e 'tell application "Terminal" to do script "cd '"'$path'"'" in selected tab of the front window' > /dev/null
	done
}


start-iterm()
{
	local project_paths=("$@")

	local project
	for path in "${project_paths[@]}"
	do
		osascript \
			-e 'tell application "iTerm"
					tell current window
						create tab with default profile
					end tell
					tell current tab of current window
						set _new_session to last item of sessions
					end tell
					tell _new_session
						select
						write text "cd '"'$path'"'"
					end tell
				end tell' > /dev/null
	done
}


start-tmux()
{
	if ! command-exists 'tmux'
	then
		printf-error 'tmux is not installed'
		exit 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	local session_name=$(basename "$WORKSPACE_PATH")
	tmux new-session -d -s "$session_name" -c "${selected_paths[0]}"

	for path in "${selected_paths[@]:1}"
	do
		tmux split-window -v -p 50 -c "${path}"
		tmux select-layout tiled
	done

	tmux -2 attach-session -t "$session_name"
}


continue-tmux()
{
	if ! command-exists 'tmux'
	then
		printf-error 'tmux is not installed'
		exit 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	tmux new-window -c "${selected_paths[0]}"

	for path in "${selected_paths[@]:1}"
	do
		tmux split-window -v -p 50 -c "${path}"
		tmux select-layout tiled
	done
}


foreach-project()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		if $OPTION_INTERACTIVE
		then
			if ! prompt-user-to-select-project "$path" 'Run your command with this repository? (y/n)'
			then
				printf '\n'
				continue
			fi
		else
			local project_name=$(basename "$path")
			printf '\e[1;4m%s\e[0m\n' "$project_name"
		fi

		bash -c "cd '$path'; ${FOREACH_ARGUMENTS[*]}"
		deal-with-failed-command $? "$path"
		printf '\n'
	done
}


foreach-project-git()
{
	FOREACH_ARGUMENTS=('git' ${FOREACH_ARGUMENTS[@]})
	foreach-project "$@"
}


show-help()
{
	local custom_action_help=''
	local index
	for (( index = 0; index < ${#CUSTOM_ACTIONS[@]}; ++index ))
	do
		local action=$(printf '%*s' -11 "${CUSTOM_ACTIONS[$index]}")
		local description="${CUSTOM_ACTIONS_DESCRIPTIONS[$index]}"
		if [ -z "$description" ]
		then
			description="\$ $SCRIPT_NAME ${CUSTOM_ACTIONS_OPTIONS[$index]} -- ${CUSTOM_ACTIONS_COMMANDS[$index]}"
		fi

		custom_action_help="$custom_action_help  $action $description\n"
	done

	local help_message=\
"Do various stuff with multiple projects.

\e[1mUSAGE\e[0m
  $SCRIPT_NAME status [-P <project-path>] [-u | -U] [-n] [-s | -r]
      [-p <project-name-pattern>] [(-b | -B) <branch-name-pattern>]

  $SCRIPT_NAME git [-P <project-path>] [-i] [-u | -U] [-n] [-s | -r]
      [-p <project-name-pattern>] [(-b | -B) <branch-name-pattern>]
      -- <git-command>...

  $SCRIPT_NAME foreach [-P <project-path>] [-i] [-u | -U] [-n] [-s | -r]
      [-p <project-name-pattern>] [(-b | -B) <branch-name-pattern>]
      -- <commands>...

  $SCRIPT_NAME open [-P <project-path>] [-t] [-i] [-u | -U] [-n] [-s | -r]
            [-p <project-name-pattern>] [(-b | -B) <branch-name-pattern>]

\e[1mACTIONS\e[0m
  status      show git status for project.
  git         run git command for each project.
  foreach     run command for each project.
  open        open projects in shell (default), Gnome-Terminal tabs or tmux panels.
$custom_action_help
\e[1mOPTIONS\e[0m
  -W | --workspace-path <path>      Search path [default: current directory].
  -p | --project <pattern>          Project name pattern.
  -B | --branch <pattern>           Current branch name pattern.
  -b | --branches <pattern>         Branch name pattern for local branches.
  -r | --remote-branches <pattern>  Branch name pattern for remote branches.
  -a | --all-branches <pattern>     Branch name pattern for all branches.
  -s | --strict                     Match next pattern strictly.
  -S | --strict-all                 Match all patterns strictly.
  -n | --negate                     Negate next pattern.
  -N | --negate-all                 Negate all patterns.
  -u | --uncommited                 Match projects with uncommited changes.
  -d | --ignore-detached            Do not match projects with detached HEAD.
  -t | --tabs                       Open projects in current terminal tabs/panels.
  -A | --apple-terminal             Open projects in Apple terminal tabs.
  -G | --gnome-terminal             Open projects in Gnome terminal tabs.
  -I | --iterm                      Open projects in iTerm tabs.
  -X | --tmux                       Open projects in tmux panels.
  -i | --interactive                Chose projects to do your stuff with.
  -g | --ignore-failed              Do not prompt to deal with error for failed commands in 'git' and 'foreach'.
  -h | --help                       Show this message.

\e[1mADDITIONAL COMMANDS\e[0m
    init                       initialize workspace resource directory (optional).
    install-completion-script  Install bash completion script for project and branch names.
    cache-workspace-info       Cache project paths and store project and branch names for completion script.

\e[1mNOTES\e[0m
    Project name is the name of the folder that is parent to '.git' folder.

    If no '-s' or '-r' option is set, then <pattern> is searched as a part of a project/branch name.

    Use quotes for '|', ';', '&&' and '||' inside <commands> for 'foreach'.

    If any <command> in 'git' or 'foreach' failes during run, then script will prompt to open that project in shell to deal with issue manually.

\e[1mEXAMPLES\e[0m
    Get git status for all projects that contain 'feature' in any of their existing branch names (-b).
    \e[1m$ $SCRIPT_NAME status -b feature\e[0m

    Checkout to branch 'master' each project, that is not (-n) on 'master' branch (-B).
    \e[1m$ $SCRIPT_NAME git -nB master -- checkout master\e[0m

    Commit changes for each project, that has uncommited changes (-u) and contains 'feature/some' in it's current branch name (-B).
    \e[1m$ $SCRIPT_NAME foreach -u -B feature/some -- git add . '&&' git commit\e[0m

    Open in tmux panels (-x) projects, that contain 'feature' in their current branch name (-b).
    \e[1m$ $SCRIPT_NAME open -x -b feature\e[0m
"

	printf-message "$help_message"
}


#
# Parameters and options parsing/validating

PARAM_TYPE_SHORT_OPTION_LIST=1
PARAM_TYPE_LONG_OPTION=2
PARAM_TYPE_DELIMITER=3
PARAM_TYPE_BAD_PARAMETER=255

check-parameter()
{
	local string=$1

	if [ "${string:0:3}" == '--' ] && [ "${#string}" == 2 ]
	then
		return $PARAM_TYPE_DELIMITER
	fi

	if [ "${string:0:2}" == '--' ]
	then
		printf '%s\n' "${string#--}"
		return $PARAM_TYPE_LONG_OPTION
	fi

	if [ "${string:0:1}" == '-' ]
	then
		printf '%s\n' "${string#-}"
		return $PARAM_TYPE_SHORT_OPTION_LIST
	fi

	return $PARAM_TYPE_BAD_PARAMETER
}


parse-option()
{
	local option=$1
	local value=$2

	case "$option" in
		W|workspace-path)
			OPTION_WORKSPACE_PATH="$value"
			return 1
			;;

		p|project)
			add-matcher 'matcher-project-name' "$value"
			return 1
			;;

		B|branch)
			add-matcher 'matcher-current-branch-name' "$value"
			return 1
			;;

		b|branches)
			add-matcher 'matcher-local-branch-name' "$value"
			return 1
			;;

		r|remote-branches)
			add-matcher 'matcher-remote-branch-name' "$value"
			return 1
			;;

		a|all-branches)
			add-matcher 'matcher-branch-name' "$value"
			return 1
			;;

		s|strict)
			OPTION_STRICT_NEXT_PATTERN=true
			;;

		S|strict-all)
			OPTION_STRICT_ALL_PATTERNS=true
			;;

		n|negate)
			OPTION_NEGATE_NEXT_PATTERN=true
			;;

		N|negate-all)
			OPTION_NEGATE_ALL_PATTERNS=true
			;;

		u|uncommited)
			OPTION_UNCOMMITED=true
			;;

		d|ignore-detached)
			OPTION_IGNORE_DETACHED=true
			;;

		t|tabs)
			OPTION_TERMINAL_TABS=true
			;;

		A|apple-terminal)
			OPTION_APPLE_TERMINAL=true
			;;

		G|gnome-terminal)
			OPTION_GNOME_TERMINAL=true
			;;

		I|iterm)
			OPTION_ITERM=true
			;;

		X|tmux)
			OPTION_TMUX=true
			;;

		i|interactive)
			OPTION_INTERACTIVE=true
			;;

		g|ignore-failed)
			OPTION_IGNORE_FAILED=true
			;;

		*)
			printf-error 'unknown option "%s"' "$option"
			exit 1
			;;
	esac
}


parse-parameters()
{
	local action=$1
	local parameters=("${@:2}")

	if [ -z "$action" ] || [ "$action" == '-h' ] || [ "$action" == '--help' ]
	then
		show-help
		return 2
	fi

	if ! array-contains "$action" "${SCRIPT_ACTIONS[@]}"
	then
		local index
		index=$(array-index-of "$action" "${CUSTOM_ACTIONS[@]}")
		if [ $? != 0 ]
		then
			printf-error 'unknown action '"'$action'"
			return 1
		fi

		parameters=(${CUSTOM_ACTIONS_OPTIONS[$index]} "${parameters[@]}")
	fi

	OPTION_ACTION="$action"

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter=$(check-parameter "${parameters[$parameter_index]}")
		local parameter_type=$?

		case $parameter_type in
			$PARAM_TYPE_SHORT_OPTION_LIST)
				local value="${parameters[$parameter_index + 1]}"

				local index
				for (( index = 0; index < ${#parameter}; ++index ))
				do
					local option="${parameter:$index:1}"
					parse-option "$option" "$value"
					if [ $? != 0 ]
					then
						(( parameter_index += 1 ))
						break;
					fi
				done

				continue
				;;

			$PARAM_TYPE_LONG_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				parse-option "$parameter" "$value"
				(( parameter_index += $? ))
				continue
				;;

			$PARAM_TYPE_DELIMITER)
				(( ++parameter_index ))
				break
				;;

			$PARAM_TYPE_BAD_PARAMETER)
				printf-error 'bad parameter format "%s"' "$parameter"
				exit 1
				;;
		esac
	done

	if [ $parameter_index == ${#parameters[@]} ]
	then
		return
	fi

	if [ $parameter_type == $PARAM_TYPE_DELIMITER ]
	then
		for (( ; parameter_index < ${#parameters[@]}; ++parameter_index ))
		do
			local parameter="${parameters[$parameter_index]}"
			FOREACH_ARGUMENTS+=("$parameter")
		done
	fi
}


validate-options()
{
	local action=$1

	case $action in
		status)
			if $OPTION_TERMINAL_TABS || $OPTION_APPLE_TERMINAL || $OPTION_GNOME_TERMINAL || $OPTION_ITERM || $OPTION_TMUX
			then
				printf-error '"-t", "--tabs", "--apple-terminal", "--gnome-terminal" or "--iterm" should be used with "open" action'
				return 1
			fi

			if $OPTION_INTERACTIVE
			then
				printf-error '"-i" ("--interactive") should be used with "open", "foreach" or "git" action'
				return 1
			fi

			if $OPTION_IGNORE_FAILED
			then
				printf-error '"-g" ("--ignore-failed") should be used with "foreach" or "git" action'
				return 1
			fi
			;;

		open)
			if $OPTION_IGNORE_FAILED
			then
				printf-error '"-g" ("--ignore-failed") should be used with "foreach" or "git" action'
				return 1
			fi
			;;

		git|foreach)
			if $OPTION_TERMINAL_TABS || $OPTION_APPLE_TERMINAL || $OPTION_GNOME_TERMINAL || $OPTION_ITERM || $OPTION_TMUX
			then
				printf-error '"-t", "--tabs", "--apple-terminal", "--gnome-terminal" or "--iterm" should be used with "open" action'
				return 1
			fi
			;;
	esac

	if ! exclusive $OPTION_TERMINAL_TABS $OPTION_APPLE_TERMINAL $OPTION_GNOME_TERMINAL $OPTION_ITERM $OPTION_TMUX
	then
		printf-error 'you can'"'"'t specify both Gnome Terminal tabs and tmux panels'
		return 1
	fi

	if [ -n "$OPTION_WORKSPACE_PATH" ] && [ ! -d "$OPTION_WORKSPACE_PATH" ]
	then
		printf-error "'"'%s'"'"' does not exist' "$OPTION_WORKSPACE_PATH"
		exit 1
	fi
}


apply-parameters()
{
	case $OPTION_ACTION in
		status)
			DO_JOB_FUNCTION=show-repositories-status
			;;

		open)
			DO_JOB_FUNCTION=open-projects
			;;

		git)
			DO_JOB_FUNCTION=foreach-project-git
			;;

		foreach)
			DO_JOB_FUNCTION=foreach-project
			;;

		init)
			mkdir -p "$CACHE_DIR_PATH"
			mkdir -p "$COMPLETION_DIR_PATH"

			local ignore_path=$(config-first-path-to-store-file "$IGNORE_FILE_NAME")
			printf '%s\n' "$IGNORE_PATHS_FILE_COMMENT" > "$ignore_path"

			printf-message 'Caching workspace info...'
			cache-workspace-info
			exit
			;;

		cache-workspace-info)
			printf-message 'Caching workspace info...'
			cache-workspace-info
			exit
			;;

		install-completion-script)
			local bash_completion_dir='/etc/bash_completion.d/'
			if ! [ -w "$bash_completion_dir" ]
			then
				printf-error 'permission denied'
				exit 1
			fi

			printf '%s\n' "$BASH_COMPLETION_SCRIPT" > "$bash_completion_dir/$SCRIPT_NAME"
			printf-message 'please restart shell'
			exit
			;;

		*)
			DO_JOB_FUNCTION=foreach-project
			local index=$(array-index-of "$OPTION_ACTION" "${CUSTOM_ACTIONS[@]}")
			FOREACH_ARGUMENTS=("${CUSTOM_ACTIONS_COMMANDS[$index]}" "${FOREACH_ARGUMENTS[@]}")
			;;
	esac

	if [ -n "$OPTION_WORKSPACE_PATH" ]
	then
		WORKSPACE_PATH=$(normalize-path "$OPTION_WORKSPACE_PATH")
	fi

	if $OPTION_UNCOMMITED
	then
		MATCHERS+=('matcher-uncommited-changes')
		MATCHER_PREFIXES+=('straight')
		MATCH_FUNCTIONS+=('inclusion-match')
		MATCHER_PATTERNS+=('')
	fi

	if $OPTION_IGNORE_DETACHED
	then
		MATCHERS+=('matcher-head-attached')
		MATCHER_PREFIXES+=('straight')
		MATCH_FUNCTIONS+=('inclusion-match')
		MATCHER_PATTERNS+=('')
	fi

	if $OPTION_NEGATE_ALL_PATTERNS
	then
		MATCH_PREFIXES=($(array-fill ${#MATCH_FUNCTIONS[@]} 'negate'))
	fi

	if $OPTION_STRICT_ALL_PATTERNS
	then
		MATCH_FUNCTIONS=($(array-fill ${#MATCH_FUNCTIONS[@]} 'strict-match'))
	fi

	if $OPTION_TERMINAL_TABS
	then
		if [ "$TERM" == 'screen' ] && [ -n "$TMUX" ]
		then
			OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-tmux
		else
			case $TERM_PROGRAM in
				Apple_Terminal)
					OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-apple-terminal
					;;

				iTerm.app)
					OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-iterm
					;;

				gnome-terminal)
					OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-gnome-terminal
					;;

				*)
					printf-error 'terminal "%s" is not supported' "$TERM_PROGRAM"
					;;
			esac
		fi
	elif $OPTION_APPLE_TERMINAL
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-apple-terminal
	elif $OPTION_GNOME_TERMINAL
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-gnome-terminal
	elif $OPTION_ITERM
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-iterm
	elif $OPTION_TMUX
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-tmux
	fi

	if $OPTION_INTERACTIVE
	then
		PROMPT_TO_USE_REPOSITORY_FUNCTION=prompt-user-to-select-project-implementation
	fi

	if $OPTION_IGNORE_FAILED
	then
		DEAL_WITH_FAILED_COMMAND_FUNCTION=nothing
	fi
}


#
# Progress

PROGRESS_BAR_CHARACTER='#'
PROGRESS_BAR_SIZE=20
PROGRESS_BAR_FILL=$(printf "$PROGRESS_BAR_CHARACTER"'%.0s' $(seq 1 $PROGRESS_BAR_SIZE))

make-progress-string()
{
	local current=$1
	local total=$2

	local percentage=$(( current * 100 / total ))
	local current_length=$(( percentage * PROGRESS_BAR_SIZE / 100 ))
	local fill="${PROGRESS_BAR_FILL:$PROGRESS_BAR_SIZE-$current_length}"
	printf '[%*s] % 3s%% (%*s/%s)' -$PROGRESS_BAR_SIZE "$fill" "$percentage" ${#total} $current $total
	return $current_length
}


print-progress-string()
{
	local current=$1
	local total=$2

	progress_string=$(make-progress-string $current $total)
	printf '\r%s' "$progress_string"
}


#
# Sanity checks

if ! command-exists 'git'
then
	printf-error 'git is not installed'
	exit 1
fi


#
# Custom commands

custom_actions_path="$(config-path-for-file "$CUSTOM_ACTIONS_FILE_NAME")"
if [ $? == 0 ]
then
	while read -r line
	do
		action=$(get-action "$line")
		command=$(get-command "$line")
		options=$(get-options "$line" "$action")
		description=$(get-description "$line")

		CUSTOM_ACTIONS+=("$action")
		CUSTOM_ACTIONS_OPTIONS+=("$options")
		CUSTOM_ACTIONS_COMMANDS+=("$command")
		CUSTOM_ACTIONS_DESCRIPTIONS+=("$description")
	done < <(grep -e '^\s*[^#]' "$custom_actions_path")
fi


#
# Script parameters

parse-parameters "$@" && validate-options $1
if [ $? != 0 ]
then
	exit 1
fi

apply-parameters


#
# Main

if [ ! -r "$CACHE_PROJECT_PATHS_PATH" ]
then
	printf-message 'Caching workspace info...'
	cache-workspace-info
fi

project_paths=($(cat "$CACHE_PROJECT_PATHS_PATH"))
project_count="${#project_paths[@]}"
if [ $project_count == 0 ]
then
	printf-error 'no projects found'
	exit 1
fi

printf-message 'Scanning projects...'
matched_projects=()
for (( index = 0; ; ++index ))
do
	print-progress-string $index $project_count

	if [ $index == $project_count ]
	then
		break;
	fi

	project_path="${project_paths[$index]}"
	run-matchers "$project_path"
	if [ $? != 0 ]
	then
		continue
	fi

	matched_projects+=("$project_path")
done

printf-message '\n'

if [ "${#matched_projects[@]}" == 0 ]
then
	printf-message 'no matching projects found'
	exit
fi

do-job "${matched_projects[@]}"
printf-message 'Done.'

