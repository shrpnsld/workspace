#!/bin/bash

#
# Essentials

SCRIPT_NAME=$(basename $0)

RED_TEXT='\e[0;31m'
NO_STYLE_TEXT='\e[0m'
ERROR_PREFIX="$SCRIPT_NAME"' error:'


printf-stderr()
{
	printf "$@" >&2
}


printf-error()
{
	printf-stderr "$ERROR_PREFIX"
	printf-stderr " $@"
	printf-stderr '\n\n'
}


printf-message()
{
	printf "$@"
	printf '\n'
}


if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	ERROR_PREFIX="$RED_TEXT$ERROR_PREFIX$NO_STYLE_TEXT"
fi


PROJECT_PATH="$PWD"

WORKSPACE_CACHE_DIR_NAME='.workspace-cache'
WORKSPACE_PROJECT_PATHS_FILE_NAME="project-paths"
WORKSPACE_PROJECT_LIST_FILE_NAME="project-list"
WORKSPACE_CURRENT_BRANCH_LIST_FILE_NAME="current-branch-list"
WORKSPACE_LOCAL_BRANCH_LIST_FILE_NAME="local-branch-list"
WORKSPACE_REMOTE_BRANCH_LIST_FILE_NAME="remote-branch-list"
WORKSPACE_BRANCH_LIST_FILE_NAME="branch-list"

WORKSPACE_CACHE_PATH="$PROJECT_PATH/$WORKSPACE_CACHE_DIR_NAME"
WORKSPACE_PROJECT_PATHS_PATH="$WORKSPACE_CACHE_PATH/$WORKSPACE_PROJECT_PATHS_FILE_NAME"
WORKSPACE_PROJECT_LIST_PATH="$WORKSPACE_CACHE_PATH/$WORKSPACE_PROJECT_LIST_FILE_NAME"
WORKSPACE_CURRENT_BRANCH_LIST_PATH="$WORKSPACE_CACHE_PATH/$WORKSPACE_CURRENT_BRANCH_LIST_FILE_NAME"
WORKSPACE_LOCAL_BRANCH_LIST_PATH="$WORKSPACE_CACHE_PATH/$WORKSPACE_LOCAL_BRANCH_LIST_FILE_NAME"
WORKSPACE_REMOTE_BRANCH_LIST_PATH="$WORKSPACE_CACHE_PATH/$WORKSPACE_REMOTE_BRANCH_LIST_FILE_NAME"
WORKSPACE_BRANCH_LIST_PATH="$WORKSPACE_CACHE_PATH/$WORKSPACE_BRANCH_LIST_FILE_NAME"

SCRIPT_COMMANDS=('status' 'git' 'foreach' 'open' 'cache-workspace-info' 'install-completion-script')

HELP_MESSAGE=\
"Do various stuff with multiple projects.

\e[1mUSAGE\e[0m
    $SCRIPT_NAME status [-P <project-path>] [-u | -U] [-n] [-s | -r]
        [-p <project-name-pattern>] [(-b | -B) <branch-name-pattern>]

    $SCRIPT_NAME git [-P <project-path>] [-i] [-u | -U] [-n] [-s | -r]
        [-p <project-name-pattern>] [(-b | -B) <branch-name-pattern>]
        -- <git-command>...

    $SCRIPT_NAME foreach [-P <project-path>] [-i] [-u | -U] [-n] [-s | -r]
        [-p <project-name-pattern>] [(-b | -B) <branch-name-pattern>]
        -- <commands>...

    $SCRIPT_NAME open [-P <project-path>] [-t] [-i] [-u | -U] [-n] [-s | -r]
              [-p <project-name-pattern>] [(-b | -B) <branch-name-pattern>]

\e[1mCOMMANDS\e[0m
    status   show git status for project.
    git      run git command for each project.
    foreach  run command for each project.
    open     open projects in bash (default), Gnome-Terminal tabs or tmux
             panels.

\e[1mOPTIONS\e[0m
    -W | --workspace-path <path>      Search path [default: current directory].
    -p | --project <pattern>          Project name pattern.
    -B | --branch <pattern>           Current branch name pattern.
    -b | --branches <pattern>         Branch name pattern for local branches.
    -r | --remote-branches <pattern>  Branch name pattern for remote branches.
    -a | --all-branches <pattern>     Branch name pattern for all branches.
    -s | --strict                     Match next pattern strictly.
    -S | --strict-all                 Match all patterns strictly.
    -n | --negate                     Negate next pattern.
    -N | --negate-all                 Negate all patterns.
    -u | --uncommited                 Match projects with uncommited changes.
    -d | --ignore-detached            Do not match projects with detached HEAD.
    -t | --tabs                       Open projects in Gnome Terminal tabs.
    -x | --tmux                       Open projects in tmux panels.
    -i | --interactive                Chose projects to do your stuff with.
    -h | --help                       Show this message.

\e[1mADDITIONAL COMMANDS\e[0m
    install-completion-script  Install bash completion script for project and
                               branch names.
    cache-workspace-info       Cache project paths and store project and branch
                               names for completion script.

\e[1mNOTES\e[0m
    Project name is the name of the folder that is parent to '.git' folder.

    If no '-s' or '-r' option is set, then <pattern> is searched as a part of
    a project/branch name.

    Use quotes for '|', ';', '&&' and '||' inside <commands> for 'foreach'.

    If any <command> in 'git' or 'foreach' failes during run, then script will
    prompt to open that project in bash to deal with issue manually.

\e[1mEXAMPLES\e[0m
    Get git status for all projects that contain 'feature' in any of their
    existing branch names (-b).
    \e[1m$ $SCRIPT_NAME status -b feature\e[0m

    Checkout to branch 'master' each project, that is not (-n) on 'master'
    branch (-B).
    \e[1m$ $SCRIPT_NAME git -nB master -- checkout master\e[0m

    Commit changes for each project, that has uncommited changes (-u) and
    contains 'feature/some' in it's current branch name (-B).
    \e[1m$ $SCRIPT_NAME foreach -u -B feature/some -- git add . '&&' git commit\e[0m

    Open in tmux panels (-x) projects, that contain 'feature' in their current
    branch name (-b).
    \e[1m$ $SCRIPT_NAME open -x -b feature\e[0m
"

BASH_COMPLETION_SCRIPT=\
'#!/bin/bash

WORKSPACE_PROJECT_LIST_FILE_PATH='"$WORKSPACE_CACHE_DIR_NAME/$WORKSPACE_PROJECT_LIST_FILE_NAME"'
WORKSPACE_CURRENT_BRANCH_LIST_FILE_PATH='"$WORKSPACE_CACHE_DIR_NAME/$WORKSPACE_CURRENT_BRANCH_LIST_FILE_NAME"'
WORKSPACE_LOCAL_BRANCH_LIST_FILE_PATH='"$WORKSPACE_CACHE_DIR_NAME/$WORKSPACE_LOCAL_BRANCH_LIST_FILE_NAME"'
WORKSPACE_REMOTE_BRANCH_LIST_FILE_PATH='"$WORKSPACE_CACHE_DIR_NAME/$WORKSPACE_REMOTE_BRANCH_LIST_FILE_NAME"'
WORKSPACE_BRANCH_LIST_FILE_PATH='"$WORKSPACE_CACHE_DIR_NAME/$WORKSPACE_BRANCH_LIST_FILE_NAME"'


_workspace-completion-is-short-option()
{
	local string=$1

	[ "${string:0:1}" == "-" ] && [ "${string:1:1}" != "-" ]
}


_workspace-completion()
{
	if [ $COMP_CWORD == 1 ]
	then
		COMPREPLY=($(compgen -W "status git foreach open cache-workspace-info install-completion-script" "${COMP_WORDS[1]}"))
		return
	fi

	local argument="${COMP_WORDS[$COMP_CWORD-1]}"

	if ([ "$argument" == "--project" ] \
		|| (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "p" ])) \
		&& [ -f "$WORKSPACE_PROJECT_LIST_FILE_PATH" ]
	then
		local projects=$(cat "$WORKSPACE_PROJECT_LIST_FILE_PATH")
		COMPREPLY=($(compgen -W "$projects" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi

	if ([ "$argument" == "--branch" ] || (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "B" ])) \
		&& [ -f "$WORKSPACE_CURRENT_BRANCH_LIST_FILE_PATH" ]
	then
		local branches=$(cat "$WORKSPACE_CURRENT_BRANCH_LIST_FILE_PATH")
		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	elif ([ "$argument" == "--branches" ] || (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "b" ])) \
		&& [ -f "$WORKSPACE_LOCAL_BRANCH_LIST_FILE_PATH" ]
	then
		local branches=$(cat "$WORKSPACE_LOCAL_BRANCH_LIST_FILE_PATH")
		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	elif ([ "$argument" == "--remote-branches" ] || (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "r" ])) \
		&& [ -f "$WORKSPACE_REMOTE_BRANCH_LIST_FILE_PATH" ]
	then
		local branches=$(cat "$WORKSPACE_REMOTE_BRANCH_LIST_FILE_PATH")
		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	elif ([ "$argument" == "--all-branches" ] || (_workspace-completion-is-short-option "$argument" && [ "${argument: -1}" == "a" ])) \
		&& [ -f "$WORKSPACE_BRANCH_LIST_FILE_PATH" ]
	then
		local branches=$(cat "$WORKSPACE_BRANCH_LIST_FILE_PATH")
		COMPREPLY=($(compgen -W "$branches" "${COMP_WORDS[$COMP_CWORD]}"))
		return
	fi
}

complete -F _workspace-completion '"$SCRIPT_NAME"


MATCH_PATTERN_FUNCTION=inclusion-match

MATCHERS=()
MATCHER_PREFIXES=()
MATCH_FUNCTIONS=()
MATCHER_PATTERNS=()

PROMPT_TO_USE_REPOSITORY_FUNCTION=nothing
OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-bash
declare -a FOREACH_ARGUMENTS
DO_JOB_FUNCTION=''


#
# Options

declare -A SCRIPT_OPTIONS

SCRIPT_OPTIONS[W]='set-workspace-path'
SCRIPT_OPTIONS[workspace-path]='set-workspace-path'

SCRIPT_OPTIONS[s]='set-strict-next-pattern'
SCRIPT_OPTIONS[strict]='set-strict-next-pattern'

SCRIPT_OPTIONS[S]='set-strict-all-patterns'
SCRIPT_OPTIONS[strict-all]='set-strict-all-patterns'

SCRIPT_OPTIONS[n]='set-negate-next-pattern'
SCRIPT_OPTIONS[negate]='set-negate-next-pattern'

SCRIPT_OPTIONS[N]='set-negate-all-patterns'
SCRIPT_OPTIONS[negate-all]='set-negate-all-patterns'

SCRIPT_OPTIONS[u]='set-match-uncommited'
SCRIPT_OPTIONS[unstaged]='set-match-uncommited'

SCRIPT_OPTIONS[d]='set-ignore-detached'
SCRIPT_OPTIONS[detached]='set-ignore-detached'

SCRIPT_OPTIONS[p]='add-project-name-matcher'
SCRIPT_OPTIONS[project]='add-project-name-matcher'

SCRIPT_OPTIONS[B]='add-current-branch-name-matcher'
SCRIPT_OPTIONS[branch]='add-current-branch-name-matcher'

SCRIPT_OPTIONS[b]='add-local-branch-name-matcher'
SCRIPT_OPTIONS[branches]='add-local-branch-name-matcher'

SCRIPT_OPTIONS[r]='add-remote-branch-name-matcher'
SCRIPT_OPTIONS[remote]='add-remote-branch-name-matcher'

SCRIPT_OPTIONS[a]='add-branch-name-matcher'
SCRIPT_OPTIONS[all]='add-branch-name-matcher'

SCRIPT_OPTIONS[t]='set-gnome-tabs'
SCRIPT_OPTIONS[tabs]='set-gnome-tabs'

SCRIPT_OPTIONS[x]='set-tmux'
SCRIPT_OPTIONS[tmux]='set-tmux'

SCRIPT_OPTIONS[i]='set-interactive'
SCRIPT_OPTIONS[interactive]='set-interactive'


OPTION_COMMAND=''
OPTION_PROJECT_PATH=''
OPTION_STRICT_MATCH=false
OPTION_NEGATE_NEXT_PATTERN=false
OPTION_NEGATE_ALL_PATTERNS=false
OPTION_STRICT_NEXT_PATTERN=false
OPTION_STRICT_ALL_PATTERNS=false
OPTION_UNCOMMITED=false
OPTION_IGNORE_DETACHED=false
OPTION_GNOME_TABS=false
OPTION_TMUX=false
OPTION_INTERACTIVE=false


set-workspace-path()
{
	local value=$1

	OPTION_PROJECT_PATH="$value"

	return 1
}


add-matcher()
{
	local matcher=$1
	local pattern=$2

	MATCHERS+=("$matcher")

	if $OPTION_NEGATE_NEXT_PATTERN
	then
		MATCHER_PREFIXES+=('negate')
		OPTION_NEGATE_NEXT_PATTERN=false
	else
		MATCHER_PREFIXES+=('straight')
	fi

	if $OPTION_STRICT_NEXT_PATTERN
	then
		MATCH_FUNCTIONS+=('strict-match')
		OPTION_STRICT_NEXT_PATTERN=false
	else
		MATCH_FUNCTIONS+=('inclusion-match')
	fi

	MATCHER_PATTERNS+=("$pattern")
}


add-project-name-matcher()
{
	local pattern=$1

	add-matcher 'matcher-project-name' "$pattern"
	return 1
}


add-current-branch-name-matcher()
{
	local pattern=$1

	add-matcher 'matcher-current-branch-name' "$pattern"
	return 1
}


add-local-branch-name-matcher()
{
	local pattern=$1

	add-matcher 'matcher-local-branch-name' "$pattern"
	return 1
}


add-remote-branch-name-matcher()
{
	local pattern=$1

	add-matcher 'matcher-remote-branch-name' "$pattern"
	return 1
}


add-branch-name-matcher()
{
	local pattern=$1

	add-matcher 'matcher-branch-name' "$pattern"
	return 1
}


set-negate-next-pattern()
{
	OPTION_NEGATE_NEXT_PATTERN=true
}


set-negate-all-patterns()
{
	OPTION_NEGATE_ALL_PATTERNS=true
}


set-strict-next-pattern()
{
	OPTION_STRICT_NEXT_PATTERN=true
}


set-strict-all-patterns()
{
	OPTION_STRICT_ALL_PATTERNS=true
}


set-match-uncommited()
{
	OPTION_UNCOMMITED=true
}


set-ignore-detached()
{
	OPTION_IGNORE_DETACHED=true
}


set-interactive()
{
	OPTION_INTERACTIVE=true
	PROMPT_TO_USE_REPOSITORY_FUNCTION=prompt-user-to-select-project-implementation
}


set-gnome-tabs()
{
	OPTION_GNOME_TABS=true
}


set-tmux()
{
	OPTION_TMUX=true
}


#
# Option dependent functions

match-pattern()
{
	"$MATCH_PATTERN_FUNCTION" "$@"
}


prompt-user-to-select-project()
{
	"$PROMPT_TO_USE_REPOSITORY_FUNCTION" "$@"
}


open-projects()
{
	"$OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION" "$@"
}


do-job()
{
	"$DO_JOB_FUNCTION" "$@"
}


#
# git pretty

repository-current-branch-pretty()
{
	local path=$1

	local output=$(cd "$path"; git -c color.ui=always branch | grep '^\* ')
	printf '%s\n' "${output}"
}


repository-branch-list-pretty()
{
	local path=$1

	local output=$(cd "$path"; git -c color.ui=always branch --all)
	printf '%s\n' "$output"
}


repository-status-pretty()
{
	local path=$1

	local project_name=$(basename "$path")
	local status=$(cd "$path"; git -c color.ui=always status)

	printf '\e[1;4m%s\e[0m\n%s\n' "$project_name" "$status"
}


#
# git raw

repository-current-branch()
{
	local path=$1

	local output=$(cd "$path"; git branch | grep -v 'HEAD detached at' | grep '^\* ')
	printf '%s\n' "${output##\* }"
}


repository-local-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-remote-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch --remote | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-branch-list()
{
	local path=$1

	local output=$(cd "$path"; git branch --all | grep -v 'HEAD detached at' | sed -e 's/* //' -e 's/  //')
	printf '%s\n' "$output"
}


repository-has-detached-head()
{
	local path=$1

	$(cd "$path"; git symbolic-ref HEAD > /dev/null 2>&1)
	[ $? != 0 ]
}


#
# Matcher functions

straight()
{
	local value=$1

	[ $value == 0 ]
}


negate()
{
	local value=$1

	[ $value != 0 ]
}


inclusion-match()
{
	local string=$1
	local pattern=$2

	[[ $string == *$pattern* ]]
}


strict-match()
{
	local string=$1
	local pattern=$2

	[ "$string" == "$pattern" ]
}


matcher-project-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local project_name=$(basename "$project_path")
	"$match_function" "$project_name" "$pattern"
}


matcher-current-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branch=$(repository-current-branch "$project_path")
	"$match_function" "$branch" "$pattern"
}


matcher-local-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-local-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-remote-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-remote-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-branch-name()
{
	local project_path=$1
	local match_function=$2
	local pattern=$3

	local branches=$(repository-branch-list "$project_path")
	local branch
	for branch in "${branches[@]}"
	do
		if "$match_function" "$branch" "$pattern"
		then
			return
		fi
	done

	return 1
}


matcher-uncommited-changes()
{
	local project_path=$1

	$(cd "$project_path"; git diff-index --quiet HEAD --)
	[ $? != 0 ]
}


matcher-head-attached()
{
	local project_path=$1

	! repository-has-detached-head "$project_path"
}


matcher-head-detached()
{
	local project_path=$1

	repository-has-detached-head "$project_path"
}


run-matchers()
{
	local project_path=$1

	local index
	for (( index = 0; index < ${#MATCHERS[@]}; ++index ))
	do
		local matcher="${MATCHERS[$index]}"
		local matcher_prefix="${MATCHER_PREFIXES[$index]}"
		local match_function="${MATCH_FUNCTIONS[$index]}"
		local pattern="${MATCHER_PATTERNS[$index]}"

		"$matcher" "$project_path" "$match_function" "$pattern"
		"$matcher_prefix" $?
		if [ $? != 0 ]
		then
			return 1
		fi
	done
}


#
# Stuff

nothing()
{
	:
}


command-exists()
{
	local name=$1

	command -v "$name" > /dev/null 2>&1
}


prompt-yes-no()
{
	local prompt=$1

	while :
	do
		local action
		printf "$prompt "
		read action
		printf '\n'
		case $action in
			y)
				return 0
				;;

			n)
				return 1
				;;

			*)
				printf-message '\n\e[34mType "y" or "n"\e[0m'
			;;
		esac
	done
}


exclusive()
{
	local values=("$@")

	local true_count=( 0 )
	local value
	for value in "${values[@]}"
	do
		if $value
		then
			(( ++true_count ))
		fi
	done

	[ $true_count -le 1 ]
}


normalize-path()
{
	local path=$1
	printf '%s\n' $(cd "$path"; pwd)
}


array-contains()
{
	local item=$1
	local array=("${@:2}")

	local value
	for value in "${array[@]}"
	do
		if [ "$value" == "$item" ]
		then
			return 0
		fi
	done

	return 1
}


#
# Jobs

install-completion-script()
{
	local bash_completion_dir='/etc/bash_completion.d/'
	if ! [ -w "$bash_completion_dir" ]
	then
		return 1
	fi

	printf '%s\n' "$BASH_COMPLETION_SCRIPT" > "$bash_completion_dir/$SCRIPT_NAME"
}


cache-project-paths()
{
	local cache_path=$1
	local workspace_path=$2

	local git_dirs=($(find "$workspace_path" '!' -path '*attic*' -type d -name '.git'))
	local project_paths=()
	local git_dir
	for git_dir in "${git_dirs[@]}"
	do
		project_paths+=("$(dirname "$git_dir")")
	done

	printf '%s\n' "${project_paths[@]}" > "$cache_path"
}


cache-project-names()
{
	local cache_path=$1
	local project_paths=("${@:2}")

	# collect project names
	local project_list=()
	local project_path
	for project_path in "${project_paths[@]}"
	do
		local project_name=$(basename "$project_path")
		project_list+=("$project_name")
	done

	# split project names into tokens and store them with project names
	local parts=()
	local project_name
	for project_name in "${project_list[@]}"
	do
		local tokens
		IFS='.-_ ' read -ra tokens <<< "$project_name"
		parts+=("${tokens[@]}")
	done
	project_list+=("${parts[@]}")

	printf '%s\n' "${project_list[@]}" | sort | uniq > "$cache_path"
}


cache-branches()
{
	local cache_path=$1
	local branch_lister=$2
	local project_paths=("${@:3}")

	# collect branches
	local branch_list=()
	local path
	for path in "${project_paths[@]}"
	do
		branch_list+=($("$branch_lister" "$path"))
	done

	# split branch names into tokens and store them with branch names
	local tokens=()
	local branch
	for branch in "${branch_list[@]}"
	do
		local components
		IFS='/' read -ra components <<< "$branch"

		tokens+=("${components[@]}")
	done
	branch_list+=("${tokens[@]}")

	printf '%s\n' "${branch_list[@]}" | sort | uniq > "$cache_path"
}


cache-workspace-info()
{
	local workspace_path=$1
	local workspace_cache_dir_name=$2
	local workspace_project_paths_file_name=$3
	local workspace_project_list_file_name=$4
	local workspace_current_branch_list_file_name=$5
	local workspace_local_branch_list_file_name=$6
	local workspace_remote_branch_list_file_name=$7
	local workspace_branch_list_file_name=$8

	local workspace_cache_dir_path="$workspace_path/$workspace_cache_dir_name"
	if [ ! -d "$workspace_cache_dir_path" ]
	then
		mkdir "$workspace_cache_dir_path"
		if [ $? != 0 ]
		then
			printf-error 'failed to create "%s" directory' "$workspace_cache_dir_path"
			return 1
		fi
	fi

	local workspace_project_paths_path="$workspace_cache_dir_path/$workspace_project_paths_file_name"
	local workspace_project_list_path="$workspace_cache_dir_path/$workspace_project_list_file_name"
	local workspace_current_branch_list_path="$workspace_cache_dir_path/$workspace_current_branch_list_file_name"
	local workspace_local_branch_list_path="$workspace_cache_dir_path/$workspace_local_branch_list_file_name"
	local workspace_remote_branch_list_path="$workspace_cache_dir_path/$workspace_remote_branch_list_file_name"
	local workspace_branch_list_path="$workspace_cache_dir_path/$workspace_branch_list_file_name"

	cache-project-paths "$workspace_project_paths_path" "$workspace_path"

	local project_paths=($(cat "$workspace_project_paths_path"))
	cache-project-names "$workspace_project_list_path" "${project_paths[@]}"
	cache-branches "$workspace_current_branch_list_path" 'repository-current-branch' "${project_paths[@]}"
	cache-branches "$workspace_local_branch_list_path" 'repository-local-branch-list' "${project_paths[@]}"
	cache-branches "$workspace_remote_branch_list_path" 'repository-remote-branch-list' "${project_paths[@]}"
	cache-branches "$workspace_branch_list_path" 'repository-branch-list' "${project_paths[@]}"
}


prompt-user-to-select-project-implementation()
{
	local project_path=$1
	local prompt=$2

	repository-status-pretty "$project_path"
	printf '\n'
	prompt-yes-no "\e[1;34m$prompt\e[0m"
}


show-help()
{
	printf-message "$HELP_MESSAGE"
}


show-repositories-status()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		repository-status-pretty "$path"
		printf '\n'
	done
}


start-bash()
{
	local project_paths=("$@")

	local gnome_terminal_options=()

	local path
	for path in "${project_paths[@]}"
	do
		if ! prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			continue
		fi

		local project_name=$(basename "$path")
		printf '\e[1;4m%s\e[0m\n' "$project_name"
		bash -c "cd $path; bash"
		printf '\n'
	done
}


start-gnome-terminal()
{
	if ! command-exists 'gnome-terminal'
	then
		printf-error 'gnome-terminal is not installed'
		exit 1
	fi

	local project_paths=("$@")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	declare -a gnome_terminal_options

	for path in "${selected_paths[@]}"
	do
		gnome_terminal_options+=("--tab --working-directory ${path}")
	done

	gnome-terminal ${gnome_terminal_options[@]}
}


start-tmux()
{
	if ! command-exists 'tmux'
	then
		printf-error 'tmux is not installed'
		exit 1
	fi

	local project_paths=("$@")

	local session_name=$(basename "$PROJECT_PATH")

	local selected_paths=()
	local path
	for path in "${project_paths[@]}"
	do
		if prompt-user-to-select-project "$path" 'Open this repository? (y/n)'
		then
			selected_paths+=("$path")
		fi
	done

	tmux new-session -d -s "$session_name" -c "${selected_paths[0]}"

	for path in "${selected_paths[@]:1}"
	do
		tmux split-window -v -p 50 -c "${path}"
		tmux select-layout tiled
	done

	tmux -2 attach-session -t "$session_name"
}


foreach-project()
{
	local repository_paths=("$@")

	local path
	for path in "${repository_paths[@]}"
	do
		if $OPTION_INTERACTIVE
		then
			if ! prompt-user-to-select-project "$path" 'Run your command with this repository? (y/n)'
			then
				printf '\n'
				continue
			fi
		else
			local project_name=$(basename "$path")
			printf '\e[1;4m%s\e[0m\n' "$project_name"
		fi

		bash -c "cd $path; ${FOREACH_ARGUMENTS[*]}"
		if [ $? != 0 ]
		then
			printf '\n'
			prompt-yes-no '\e[1;31mCommand exited with non-zero code. Do you want to open this project in bash? (y/n)\e[0m'
			if [ $? == 0 ]
			then
				bash -c "cd $path; bash"
			fi
		fi

		printf '\n'
	done
}


foreach-project-git()
{
	FOREACH_ARGUMENTS=('git' ${FOREACH_ARGUMENTS[@]})
	foreach-project "$@"
}


#
# Parameters and options parsing/validating

is-option()
{
	local string=$1

	[ "${string:0:1}" == '-' ]
}


PARAM_TYPE_SHORT_OPTION_LIST=1
PARAM_TYPE_LONG_OPTION=2
PARAM_TYPE_DELIMITER=3
PARAM_TYPE_BAD_PARAMETER=255

check-parameter()
{
	local string=$1

	if [ "${string:0:3}" == '--' ] && [ "${#string}" == 2 ]
	then
		return $PARAM_TYPE_DELIMITER
	fi

	if [ "${string:0:2}" == '--' ]
	then
		printf '%s\n' "${string#--}"
		return $PARAM_TYPE_LONG_OPTION
	fi

	if [ "${string:0:1}" == '-' ]
	then
		printf '%s\n' "${string#-}"
		return $PARAM_TYPE_SHORT_OPTION_LIST
	fi

	return $PARAM_TYPE_BAD_PARAMETER
}


parse-short-option-list()
{
	local option_list=$1
	local value=$2

	local index
	for (( index = 0; index < ${#option_list}; ++index ))
	do
		local option="${option_list:$index:1}"

		if [ ! ${SCRIPT_OPTIONS[$option]+_} ]
		then
			printf-error 'unknown option "%s"' "$option"
			exit 1
		fi

		"${SCRIPT_OPTIONS[$option]}" "$value"
		local retval=$?
		if [ $retval != 0 ]
		then
			return $retval
		fi
	done
}


parse-long-option()
{
	local option=$1
	local value=$2

	if [ ! ${SCRIPT_OPTIONS[$option]+_} ]
	then
		printf-error 'unknown option "%s"' "$option"
		exit 1
	fi

	"${SCRIPT_OPTIONS[$option]}" "$value"
	return $?
}


parse-parameters()
{
	local command=$1
	local parameters=("${@:2}")

	if [ -z "$command" ] || [ "$command" == '-h' ] || [ "$command" == '--help' ]
	then
		show-help
		return 2
	fi

	if ! array-contains "$command" "${SCRIPT_COMMANDS[@]}"
	then
		printf-error 'unknown command '"'$command'"
		return 1
	fi

	OPTION_COMMAND="$command"

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter=$(check-parameter "${parameters[$parameter_index]}")
		local parameter_type=$?

		case $parameter_type in
			$PARAM_TYPE_SHORT_OPTION_LIST)
				local value="${parameters[$parameter_index + 1]}"
				parse-short-option-list "$parameter" "$value"
				(( parameter_index += $? ))
				continue
				;;

			$PARAM_TYPE_LONG_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				parse-long-option "$parameter" "$value"
				(( parameter_index += $? ))
				continue
				;;

			$PARAM_TYPE_DELIMITER)
				(( ++parameter_index ))
				break
				;;

			$PARAM_TYPE_BAD_PARAMETER)
				printf-error 'bad parameter format "%s"' "$parameter"
				exit 1
				;;
		esac
	done

	if [ $parameter_index == ${#parameters[@]} ]
	then
		return
	fi

	if [ $parameter_type == $PARAM_TYPE_DELIMITER ]
	then
		for (( ; parameter_index < ${#parameters[@]}; ++parameter_index ))
		do
			local parameter="${parameters[$parameter_index]}"
			FOREACH_ARGUMENTS+=("$parameter")
		done
	fi
}


validate-options()
{
	local command=$1

	if ! exclusive $OPTION_GNOME_TABS $OPTION_TMUX
	then
		printf-error 'you can'"'"'t specify both Gnome Terminal tabs and tmux panels'
		return 1
	fi

	case $command in
		status)
			if $OPTION_GNOME_TABS
			then
				printf-error "'"'-t'"'"' or '"'"'--tabs'"'"' should be used with '"'"'open'"'"' action'
				return 1
			fi

			if $OPTION_TMUX
			then
				printf-error "'"'-x'"'"' or '"'"'--tmux'"'"' should be used with '"'"'open'"'"' action'
				return 1
			fi

			if $OPTION_INTERACTIVE
			then
				printf-error "'"'-i'"'"' or '"'"'--interactive'"'"' should be used with '"'"'open'"'"' action'
				return 1
			fi
			;;

		git|foreach)
			if $OPTION_GNOME_TABS
			then
				printf-error "'"'-t'"'"' or '"'"'--tabs'"'"' should be used with '"'"'open'"'"' action'
				return 1
			fi
			if $OPTION_TMUX
			then
				printf-error "'"'-x'"'"' or '"'"'--tmux'"'"' should be used with '"'"'open'"'"' action'
				return 1
			fi
			;;
	esac

	if [ -n "$OPTION_PROJECT_PATH" ] && [ ! -d "$OPTION_PROJECT_PATH" ]
	then
		printf-error "'"'%s'"'"' does not exist' "$OPTION_PROJECT_PATH"
		exit 1
	fi
}


apply-options()
{
	case $OPTION_COMMAND in
		status)
			DO_JOB_FUNCTION=show-repositories-status
			;;

		open)
			DO_JOB_FUNCTION=open-projects
			;;

		git)
			DO_JOB_FUNCTION=foreach-project-git
			;;

		foreach)
			DO_JOB_FUNCTION=foreach-project
			;;

		cache-workspace-info)
			printf-message 'Caching workspace info...'
			cache-workspace-info "$PROJECT_PATH" "$WORKSPACE_CACHE_DIR_NAME" "$WORKSPACE_PROJECT_PATHS_FILE_NAME" "$WORKSPACE_PROJECT_LIST_FILE_NAME" "$WORKSPACE_CURRENT_BRANCH_LIST_FILE_NAME" "$WORKSPACE_LOCAL_BRANCH_LIST_FILE_NAME" "$WORKSPACE_REMOTE_BRANCH_LIST_FILE_NAME" "$WORKSPACE_BRANCH_LIST_FILE_NAME"
			exit
			;;

		install-completion-script)
			install-completion-script
			if [ $? == 1 ]
			then
				printf-error 'permission denied'
				exit 1
			fi

			printf-message 'please restart shell'
			exit
			;;
	esac

	PROJECT_PATH=$(normalize-path "$OPTION_PROJECT_PATH")

	if $OPTION_STRICT_MATCH
	then
		MATCH_PATTERN_FUNCTION=strict-match
	fi

	if $OPTION_UNCOMMITED
	then
		MATCHERS+=('matcher-uncommited-changes')
		MATCHER_PREFIXES+=('straight')
		MATCH_FUNCTIONS+=('inclusion-match')
		MATCHER_PATTERNS+=('')
	fi

	if $OPTION_IGNORE_DETACHED
	then
		MATCHERS+=('matcher-head-attached')
		MATCHER_PREFIXES+=('straight')
		MATCH_FUNCTIONS+=('inclusion-match')
		MATCHER_PATTERNS+=('')
	fi

	if $OPTION_NEGATE_ALL_PATTERNS
	then
		local index
		for (( index = 0; index < ${#MATCHER_PREFIXES[@]}; ++index ))
		do
			MATCHER_PREFIXES[$index]='negate'
		done
	fi

	if $OPTION_STRICT_ALL_PATTERNS
	then
		local index
		for (( index = 0; index < ${#MATCH_FUNCTIONS[@]}; ++index ))
		do
			MATCH_FUNCTIONS[$index]='strict-match'
		done
	fi

	if $OPTION_GNOME_TABS
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-gnome-terminal
	elif $OPTION_TMUX
	then
		OPEN_REPOSITORIES_IN_TERMINAL_FUNCTION=start-tmux
	fi
}


#
# Progress

make-progress-string()
{
	PROGRESS_BAR_CHARACTER='#'
	PROGRESS_BAR_SIZE=20
	PROGRESS_BAR_FILL=$(printf "$PROGRESS_BAR_CHARACTER"'%.0s' $(seq 1 $PROGRESS_BAR_SIZE))

	local current=$1
	local total=$2

	local percentage=$(( current * 100 / total ))
	local current_length=$(( percentage * PROGRESS_BAR_SIZE / 100 ))
	local fill="${PROGRESS_BAR_FILL:$PROGRESS_BAR_SIZE-$current_length}"
	printf '[%*s] % 3s%% (%*s/%s)' -$PROGRESS_BAR_SIZE "$fill" "$percentage" ${#total} $current $total
	return $current_length
}


print-progress-string()
{
	local current=$1
	local total=$2

	progress_string=$(make-progress-string $current $total)
	printf '\r%s' "$progress_string"
}


#
# Sanity checks

if ! command-exists 'git'
then
	printf-error 'git is not installed'
	exit 1
fi


#
# Script parameters

parse-parameters "$@"
if [ $? != 0 ]
then
	exit 1
fi

if ! validate-options $1
then
	exit 1
fi

apply-options


#
# Main

if [ ! -f "$WORKSPACE_PROJECT_PATHS_PATH" ] || [ ! -f "$WORKSPACE_PROJECT_LIST_PATH" ]
then
	printf-message 'Caching workspace info...'
	cache-workspace-info "$PROJECT_PATH" "$WORKSPACE_CACHE_DIR_NAME" "$WORKSPACE_PROJECT_PATHS_FILE_NAME" "$WORKSPACE_PROJECT_LIST_FILE_NAME" "$WORKSPACE_CURRENT_BRANCH_LIST_FILE_NAME" "$WORKSPACE_LOCAL_BRANCH_LIST_FILE_NAME" "$WORKSPACE_REMOTE_BRANCH_LIST_FILE_NAME" "$WORKSPACE_BRANCH_LIST_FILE_NAME"
fi

project_paths=($(cat "$WORKSPACE_PROJECT_PATHS_PATH"))
project_count="${#project_paths[@]}"
if [ $project_count == 0 ]
then
	printf-error 'no projects found'
	exit 1
fi

declare -a matched_projects
declare -a branch_list
index=( -1 )

printf-message 'Scanning projects...'
while :
do
	(( ++index ))
	project_path="${project_paths[$index]}"

	print-progress-string $index $project_count

	if [ $index == $project_count ]
	then
		break;
	fi

	branch_list+=($(repository-branch-list "$project_path"))

	run-matchers "$project_path"
	if [ $? != 0 ]
	then
		continue
	fi

	matched_projects+=("$project_path")
done

printf-message '\n'

if [ "${#matched_projects[@]}" == 0 ]
then
	printf-error 'no matched projects found'
	exit 1
fi

do-job "${matched_projects[@]}"
printf-message 'Done.'

